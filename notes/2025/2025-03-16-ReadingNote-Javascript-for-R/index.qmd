---
title: "Note: Interactive Data Visualization for R"
author: Jihong Zhang <a href="https://orcid.org/0000-0003-2820-3734"><img src="/images/ORCID-iD_icon_24x24.png" alt=""/></a>
title-block-banner: false
date: "2025-03-16"
date-modified: "`{r} Sys.Date()`"
categories:
  - htmltools
  - htmlwidgets
  - Javascript
execute: 
  message: false
  warning: false  
fig-cap-location: top  
toc-depth: 3
toc-expand: true
toc-location: left
number-sections: true
page-layout: full
code-tools: false
comments: false
fig-align: center
format: html
bibliography: references.bib
---

::: objectives
## Overview {.unnumbered}

The interactive web app development in R requires multiple relevant skillsets: HTML, CSS, Javascript, R, and Shiny etc. This is a reading note covering the following books:

1.  {[Javascript for R](https://book.javascript-for-r.com/widgets-intro-intro)} (JFR) by John Coene (2021-04-19).
2.  {[Interactive web-based data visualization with R, plotly, and shiny](https://plotly-r.com)} (IVRPS) by Carson Sievert (2019-12-19).
3.  {[Outstanding User Interfaces with Shiny](https://unleash-shiny.rinterface.com/)} (OUIS) by David Granjon (2022-03-14).
    -   Understand how Shiny deals with the classic web development standards and what are the main differences.
    -   Manipulate **HTML tags** from R to create custom layouts.
    -   Harness the power of **CSS and JavaScript** to quickly design apps standing out from the pack.
    -   Discover the steps to import and convert existing web frameworks like Bootstrap 4 and Framework7.
    -   Learn how Shiny internally deals with inputs.
    -   Learn more about less-documented Shiny mechanisms (websockets, sessions, â€¦).

```{r}
#| code-fold: true

if (!require("memer")) {
  devtools::install_github("sctyner/memer") 
  library(memer)
}else{
  library(memer) # devtools::install_github("sctyner/memer") 
}

meme_get("DistractedBf") %>% 
  meme_text_distbf("Javascript", "data scientists", "ggplot2")
```
:::

## Relevant resources

1.  [htmltools](https://github.com/rstudio/htmltools) package
    -   [Chapter 2: Manipulate HTML tags from R with {htmltools}](https://unleash-shiny.rinterface.com/htmltools-overview) in Outstanding User Interfaces with Shiny

## ObservableHQ with Quarto

There are two ways to take advantage of Observable Javascript in Quarto:

1.  Write OJS code in `{ojs}` cells in the Quarto document (see more [details](https://quarto.org/docs/interactive/ojs/)).
2.  Write code using ObservableHQ notebook and share embedded output

::: maccaution
Either way has pros and cons: First method can make use of various R packages for data sciences (i.e., `tidyverse`) if you are R users, it also has seamlessly embedded into `.qmd` file. However, `{ojs}` cells do not have autocompletion nor allow you to execute cells without rendering the whole Quarto markdown document. Second method, on the other hand, allows you to write syntax-highlighted OJS code with autocompletion and execute the cells lively, but you have to use Javascript libraries to do data analysis (i.e., [Aquero](https://idl.uw.edu/arquero/api/)).

**A mixing method** combing the goods of both methods is performing the data analysis in R, export it to CSV locally or into the cloud (e.g., Google), then using the file attachment function for reading data in the ObservableHQ. Alternatively, if you are not mentally attached to Quarto markdown, the Observable [Framework](https://observablehq.com/framework/getting-started) is another option of standalone data visualization project.
:::

```{ojs}
//| code-summary: "Method 1: {ojs} cell"
//| code-fold: true

Plot.rectY({length: 100000}, 
           Plot.binX({y: "count"}, {x: d3.randomNormal()})
          ).plot()

```

Since ObservableHQ is likely long-term maintained, I prefer the second method.

To embed [ObservableHQ](https://observablehq.com/) notebook cells into Quarto, make sure your ObservableHQ notebook is public, then take the following steps in ObservableHQ: $\vdots$ \> `Export` \> `Embed Cells`.

::: macwindow
Method 2: One example of embeded cell is like this:

<iframe width="100%" height="369" frameborder="0" src="https://observablehq.com/embed/c03db5cde95f513e?cells=chart">

</iframe>
:::

The Observable Framework offers another option to deploy your javascript+R dashboard. See here for detailed [code](https://observablehq.com/framework/getting-started#next-steps) for the get started of local development. Following is the toy example I created (Github [link](https://github.com/JihongZ/hello-framework)).

::: {.column-screen}
<iframe width="100%" height="1000" frameborder="0"  src="https://jihongz.observablehq.cloud/hello-framework" title="Hello World Observable Framework"></iframe>
:::

## JFR Chapter 3: Introduction to Widgets

> The `htmlwidgets` package originates from the rCharts package [@vaidyanathanRamnathvRCharts2025] in 2012 by Ramnath Vaidyanathan. It brought together a plethora of data visualisation JavaScript libraries, datamaps, highcharts, morris.js, and many more. Though no longer maintained rCharts ultimately paved the way towards a framework for interactive visualisations in R: two years later, in 2014, Ramnath and other prominent R users start working on htmlwidgets.

{{< include package_info/plotly.qmd >}}

### crosstalk package

-   `crosstalk` package enable multiple html widgets to communicate.
    -   `bscols` function put the visualization and table side-by-side
-   Not all html widgets support `crosstalk` package. You can check out the list of compatible HTML widgets [here](https://rstudio.github.io/crosstalk/widgets.html).

::: callout-note
### Share Data between HTML widgets

You can select cases in HTML tables and the selection will be reflected in the plot.

```{r}
library(DT)
library(crosstalk)


sd <- SharedData$new(iris[, c("Sepal.Length", "Sepal.Width")])

crosstalk::bscols(
  device = "lg",
  datatable(sd, width = "100%"),
  plot_ly(sd, x=~Sepal.Length, y=~Sepal.Width)
)
```
:::

## JFR Chapter 5: Create a widget

This function puts together the minimalistic structure necessary to implement an htmlwidget and opens `play.R`, `play.js`, and `play.yaml` in the RStudio IDE or the default text editor.

```{r}
#| eval: false
usethis::create_package("playground")
htmlwidgets::scaffoldWidget("play")
#>Created boilerplate for widget constructor R/play.R
#>Created boilerplate for widget dependencies at inst/htmlwidgets/play.yaml
#>Created boilerplate for widget javascript bindings at inst/htmlwidgets/play.js
```

Here's the directory structure for the project `playground`:

```{r}
fs::dir_tree("playground")
```

Then, use `document()` ({{< kbd cmd+shift+D >}}) and `load_all()` ({{< kbd cmd+shift+L >}}) to document and load the package.

```{r}
#| eval: false
devtools::document()
devtools::load_all()
```

There is only one function in the playground package, `play()`, which is the constructor function for the widget. It takes a message as input and returns the message to HTML output.

```{r}
#| eval: false
play(message = "This is a widget!")
```

```{r, file="./playground/R/play.R"}
#| eval: false
#| code-summary: "Click to see the source code of play.R"
#| code-fold: true
```
