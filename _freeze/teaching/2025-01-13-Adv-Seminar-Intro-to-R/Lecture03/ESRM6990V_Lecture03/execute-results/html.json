{
  "hash": "a535e3ef2278b673c9806ad52b2d92d4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lecture 03: R Functions\"\nsubtitle: \"R Function\"\ndate: \"2025-01-28\"\ndate-modified: \"2024-10-11\"\nexecute: \n  echo: true\n  warning: false\n  eval: false\noutput-location: default\ncode-annotations: below\nformat: \n  html:\n    code-tools: true\n    code-line-numbers: false\n    code-fold: false\n    number-offset: 1\n  uark-revealjs:\n    scrollable: true\n    chalkboard: true\n    embed-resources: false\n    code-fold: false\n    number-sections: false\n    footer: \"ESRM 64503 - Lecture 03: Object/Function/Package\"\n    slide-number: c/t\n    tbl-colwidths: auto\n    output-file: slides-index.html\n---\n\n\n\n\n\n\n# R Function\n\n## Prebuilt functions\n\n-   **Functions**: Once we defined the objects, the data analysis process can usually be described as [a series of *functions*]{.underline} applied to the data.\n\n    -   In other words, we considered \"function\" as a set of pre-specified operations (e.g., macro in SAS)\n\n    -   R includes several **predefined functions** and most of the analysis pipelines we construct make extensive use of these.\n\n    -   We already used or discussed the `install.packages`, `library`, and `ls` functions. We also used the function `sqrt` to solve the quadratic equation above.\n\n-   **Evaluation**: In general, we need to use parentheses followed by a function name to evaluate a function.\n\n    -   If you type `ls`, the function is not evaluated and instead R shows you the code that defines the function. If you type [`ls()`](https://rdrr.io/r/base/ls.html) the function is evaluated and, as seen above, we see objects in the workspace.\n\n-   **Function Arguments:** Unlike `ls`, most functions require one or more *arguments* to specify the settings of the function.\n\n    -   For example, we assign different object to the argument of the function `log`. Remember that we earlier defined `coef_a` to be 1:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.079442\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Functions in R\n\n### Overview of Functions\n\n-   **Definition**: Functions are blocks of code designed to perform specific tasks.\n-   **Purpose**:\n    -   Automate repetitive tasks.\n    -   Increase code reusability and readability.\n        -   A good rule of thumb is to consider writing a function whenever you’ve copied and pasted a block of code more than twice\n-   **Key Characteristics**:\n    -   Inputs (arguments) → Process → Output (return value).\n    -   Functions can contain other functions.\n\n------------------------------------------------------------------------\n\n### Benefits of Using Functions\n\n1.  **Code Reusability**: Write once, use multiple times.\n2.  **Readability**: Simplify complex code.\n3.  **Debugging**: Isolate errors within specific functions.\n4.  **Scalability**: Build modular, extensible codebases.\n\n# Factor Creation\n\n## Helpful function: Pipe\n\n-   In R, a pipe is a powerful operator (\"\\|\\>\" or \"%\\>%\") used to streamline the flow of data analysis.\n    -   A operator is a special function with the name as symbol and left/right hand sides as arguments.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 2\n`+`(1, 2)\n```\n:::\n\n\n\n\n\n\n-   It enables chaining multiple operations together in a readable, sequential manner.\n\n-   Key idea: The pipe operator passes the output of one function as the first argument to the next function, eliminating the need for intermediate variables or nested function calls.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> function1() |> function2() |> function3()\n```\n:::\n\n\n\n\n\n\nThis is equivalent to:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction3(function2(function1(data)))\n```\n:::\n\n\n\n\n\n\n------------------------------------------------------------------------\n\n### Example: With vs. Without Pipe\n\nExample: Without Pipe\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Without pipe\nresult <- filter(mtcars, mpg > 20)\nresult <- select(result, mpg, cyl)\nresult <- arrange(result, desc(mpg))\n```\n:::\n\n\n\n\n\n\nExample: With Pipe\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# With pipe\nmtcars |> \n  filter(mpg > 20) |> \n  select(mpg, cyl) |> \n  arrange(desc(mpg))\n```\n:::\n\n\n\n\n\n\n-   Which one you prefer?\n\n## Creating Custom Function\n\n### Example: Celsius to Fahrenheit Converter\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncelsius_to_fahrenheit <- function(temp_c) {\n  temp_f <- (temp_c * 9/5) + 32\n  return(temp_f)\n}\n\ncelsius_to_fahrenheit(25)  # Output: 77\n```\n:::\n\n\n\n\n\n\n-   Converts a temperature from Celsius to Fahrenheit.\n-   Input: `temp_c` (temperature in Celsius).\n-   Output: `temp_f` (temperature in Fahrenheit).\n\n------------------------------------------------------------------------\n\n### Example: Standardization\n\n-   Did you spot the mistake?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\ndf <- tibble(\n  a = rnorm(5),\n  b = rnorm(5),\n  c = rnorm(5),\n  d = rnorm(5),\n)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n       a      b      c       d\n   <dbl>  <dbl>  <dbl>   <dbl>\n1 -0.972  0.542  1.52   0.764 \n2  0.676  0.922 -1.17   0.738 \n3 -1.44   0.447 -0.853  0.381 \n4  1.53  -0.366  0.588 -0.0877\n5  0.736 -1.14  -1.42  -0.167 \n```\n\n\n:::\n\n```{.r .cell-code}\ndf |> mutate(\n  a = (a - mean(a, na.rm = TRUE)) / sd(a),\n  b = (b - mean(a, na.rm = TRUE)) / sd(b),\n  c = (c - mean(c, na.rm = TRUE)) / sd(c),\n  d = (d - mean(d, na.rm = TRUE)) / sd(d),\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n       a      b      c      d\n   <dbl>  <dbl>  <dbl>  <dbl>\n1 -0.860  0.653  1.41   0.993\n2  0.454  1.11  -0.710  0.934\n3 -1.23   0.539 -0.463  0.126\n4  1.13  -0.441  0.673 -0.937\n5  0.502 -1.38  -0.913 -1.12 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n-   `tibble` creates a data frame with 4 columns\n-   `mutate` creates new columns - generate standardized scores of all columns\n\n------------------------------------------------------------------------\n\n-   Extract the \"**argument**\":\n    -   The **arguments** are things that vary across calls and our analysis above tells us that we have just one. We’ll call it x because this is the conventional name for a numeric vector.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstandardized <- function(x){\n  (x - mean(x, na.rm = TRUE)) / sd(x)\n}\n\ndf |> mutate(\n  a = standardized(a),\n  b = standardized(b),\n  c = standardized(c),\n  d = standardized(d)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n       a      b      c      d\n   <dbl>  <dbl>  <dbl>  <dbl>\n1 -0.860  0.557  1.41   0.993\n2  0.454  1.01  -0.710  0.934\n3 -1.23   0.442 -0.463  0.126\n4  1.13  -0.538  0.673 -0.937\n5  0.502 -1.47  -0.913 -1.12 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n------------------------------------------------------------------------\n\n### Exercise: Rescale\n\n-   Create a new function called `rescale` to simplify following code:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> mutate(\n  a = (a - mean(a, na.rm = TRUE)) / (max(a) - min(a)),\n  b = (b - mean(b, na.rm = TRUE)) / (max(b) - min(b)),\n  c = (c - mean(c, na.rm = TRUE)) / (max(c) - min(c)),\n  d = (d - mean(d, na.rm = TRUE)) / (max(d) - min(d)),\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n       a      b      c       d\n   <dbl>  <dbl>  <dbl>   <dbl>\n1 -0.364  0.224  0.607  0.471 \n2  0.192  0.408 -0.305  0.443 \n3 -0.520  0.177 -0.199  0.0599\n4  0.480 -0.216  0.290 -0.444 \n5  0.212 -0.592 -0.393 -0.529 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n-   The basic skeleton of function is like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname <- function(arguments) {\n  body\n}\n```\n:::\n\n\n\n\n\n\n-   A name. Here we’ll use 'rescale' because this function rescales a vector to lie between 0 and 1.\n\n-   The body. The body is the code that’s repeated across all the calls.\n\n## Anatomy of a Function\n\n### Example Code for one function\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name <- function(argument1, argument2 = default_value) {\n  # Body of the function\n  result <- argument1 + argument2\n  return(result)\n}\n```\n:::\n\n\n\n\n\n\n-   **Components**:\n    -   `function_name`: Name of the function.\n    -   `arguments`: Inputs provided to the function.\n    -   `body`: Code block that performs the computation.\n    -   `return()`: Specifies the output of the function.\n\n------------------------------------------------------------------------\n\n## Arguments in Functions\n\n### Default Arguments\n\n-   Assign default values to arguments to make them optional.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreet <- function(name = \"World\") {\n  return(paste(\"Hello,\", name))\n}\n\ngreet()            # Output: \"Hello, World\"\ngreet(\"R User\")    # Output: \"Hello, R User\"\n```\n:::\n\n\n\n\n\n\n### Flexible Arguments\n\n-   `...`: Allow a function to accept a variable number of arguments.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_numbers <- function(...) {\n  numbers <- c(...) # combine into a vector\n  return(sum(numbers))\n}\n\nsum_numbers(1, 2, 3, 4)  # Output: 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\n\n\n\n-   Look at the help page of `mean`, tell me why we can have `y` argument in `mean` function\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x = c(1, 2, 3), y = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n------------------------------------------------------------------------\n\n-   Flexible argument can be useful when you do not know users want to use which argument\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(y = 3, x = 8, z = 9, one_vector = c(7, TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\n(3 + 8 + 9 + 7 + 1 ) / 5 # what we expect\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.6\n```\n\n\n:::\n\n```{.r .cell-code}\nflexible_mean <- function(...){\n  return(mean(x = c(...)))\n}\nflexible_mean(y = 3, x = 8, z = 9, one_vector = c(7, TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.6\n```\n\n\n:::\n:::\n\n\n\n\n\n\n-   Question: test the `sum` function, tell me why `sum` can accept flexible arguments.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(y = 3, x = 8, z = 9, one_vector = c(7, TRUE))\n```\n:::\n\n\n\n\n\n\n------------------------------------------------------------------------\n\n## Returning Values\n\n-   Functions return the last evaluated expression by default.\n-   Use `return()` for clarity.\n\n### Example: Summing Two Numbers\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd <- function(x, y) {\n  return(x + y)\n}\n\nadd(10, 5)  # Output: 15\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n:::\n\n\n\n\n\n\n------------------------------------------------------------------------\n\n## Nested Functions\n\n-   Functions can call other functions.\n\n### Example: Calculating BMI\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbmi <- function(weight, height) {\n  return(weight / (height^2))\n}\n\nbmi(70, 1.75)  # Output: 22.86\n```\n:::\n\n\n\n\n\n\n-   Combines mathematical operations into a single function.\n\n------------------------------------------------------------------------\n\n## Function Scope\n\n-   **Local Scope**: Variables defined inside a function are local to that function.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 5\nprint_x <- function(x) {x = 3; return(x)}\nx\n```\n:::\n\n\n\n\n\n\n-   **Global Scope**: Variables defined outside a function are accessible throughout the script.\n\n------------------------------------------------------------------------\n\n### Example: Local Scope\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd <- function(x, y) {\n  result <- x + y\n  return(result)\n}\n\nadd(2, 3)   # Output: 5\nresult      # Error: object 'result' not found\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd <- function(x, y) {\n  result <<- x + y\n  return(result)\n}\nadd(2, 3)   # Output: 5\nresult \n```\n:::\n\n\n\n\n\n\n------------------------------------------------------------------------\n\n## Exercise 03\n\n-   Create a blank Quarto document\n-   Finish Exercise 03: R Function in the Quarto\n\n## Summary\n\n-   Functions are the cornerstone of programming in R.\n-   They encapsulate reusable logic, making code efficient and modular.\n-   Key concepts include arguments, return values, and scope.\n-   Practice writing functions to automate tasks and solve complex problems.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}