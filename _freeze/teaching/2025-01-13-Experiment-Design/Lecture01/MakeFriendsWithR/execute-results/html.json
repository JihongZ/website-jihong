{
  "hash": "91cb379c2e389c5297775b79a2b5a859",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Example 01: Make Friends with R\"\nexecute: \n  eval: false\nformat: \n  html:\n    toc: true\n    toc_float: true\n    toc_depth: 2\n    toc_collapsed: true\n    number-sections: true\n    code-tools: true\n    code-fold: show\n    code-summary: \"Hide the code\"\n---\n\n# How to use this file\n\n1.  This file was created using Quarto, a type of document that allows you to review and execute all R code on this webpage.\n\n2.  To test a certain chunk of code, click the \"copy\" icon in the upper right corner of the chunk block (see screenshot below)\n\n    -   ![](figures/R-copy-paste.png)\n\n    -   Try copying the following code\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        a = 1 + 1\n        b = a + 1\n        print(b)\n        ```\n        :::\n\n\n3.  To review the whole file, click `</> Code` next to the title of this page.\n    Find `View Source` and click the button.\n    Then, you can paste the content into a newly created Quarto Document.\n\n    ![](figures/code-copy-paste.png)\n\n# Getting Started with R\n\n## What is R?\n\nR is a powerful programming language and environment specifically designed for statistical computing and graphics.\nIt's free, open-source, and has a vast ecosystem of packages for data analysis, visualization, and machine learning.\n\n## Why R?\n\n-   **Free and Open Source**: No licensing costs\n-   **Extensive Package Ecosystem**: Over 18,000 packages available\n-   **Excellent for Statistics**: Built by statisticians, for statisticians\n-   **Great Visualization**: ggplot2 and other packages for beautiful graphics\n-   **Reproducible Research**: R Markdown and Quarto for literate programming\n-   **Active Community**: Large, helpful community of users\n\n## R vs RStudio\n\n-   **R**: The programming language and computing environment\n\n    ![](images/paste-3.png)\n\n-   **RStudio**: An integrated development environment (IDE) that makes R easier to use\n\n    ![](images/paste-2.png)\n\n# Suggestion in R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R comments begin with a # -- there are no multiline comments\n\n# RStudio helps you build syntax\n#   GREEN: Comments and character values in single or double quotes\n#   BLUE: Functions and keywords\n#   BLACK: Variable names and values\n\n# You can use the tab key to complete object names, functions, and arguments\n\n# R is case sensitive. That means R and r are two different things.\n\n# Good naming conventions:\n#   - Use descriptive names: my_data instead of x\n#   - Use underscores or dots: my_data or my.data\n#   - Avoid spaces and special characters (except . and _)\n#   - Don't start with numbers: 1data is invalid, data1 is valid\n```\n:::\n\n\n# Basic Data Types in R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R has several basic data types:\n\n# 1. Numeric (double) - decimal numbers\nnumeric_value <- 3.14\nclass(numeric_value)\n\n# 2. Integer - whole numbers\ninteger_value <- 42L  # The L suffix makes it an integer\nclass(integer_value)\n\n# 3. Character (string) - text\ncharacter_value <- \"Hello, R!\"\nclass(character_value)\n\n# 4. Logical (boolean) - TRUE/FALSE\nlogical_value <- TRUE\nclass(logical_value)\n\n# 5. Complex - complex numbers\ncomplex_value <- 3 + 4i\nclass(complex_value)\n\n# Check the type of any object\ntypeof(numeric_value)\nis.numeric(numeric_value)\nis.character(character_value)\n```\n:::\n\n\n# R Functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# In R, every statement is a function\n\n# The print function prints the contents of what is inside to the console\nprint(x = 10)\n\n# The terms inside the function are called the arguments; here print takes x\n#   To find help with what the arguments are use:\n?print\n\n# Each function returns an object\nprint(x = 10)\n\n# You can determine what type of object is returned by using the class function\nclass(print(x = 10))\n\n# Function syntax: function_name(argument1, argument2, ...)\n# Examples of common functions:\nsqrt(16)           # Square root\nabs(-5)            # Absolute value\nround(3.14159, 2)  # Round to 2 decimal places\nlength(c(1,2,3,4)) # Length of a vector\nsum(c(1,2,3,4))    # Sum of values\nmean(c(1,2,3,4))   # Mean of values\n```\n:::\n\n\n# Vectors - The Building Blocks\n\nVectors are the most basic data structure in R. They are one-dimensional arrays that can contain multiple elements of the same type (e.g., all numbers, all text, or all logical values).\n\n## Creating Vectors\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use the c() function (combine) to create vectors\nnumeric_vector <- c(1, 2, 3, 4, 5)\ncharacter_vector <- c(\"apple\", \"banana\", \"cherry\")\nlogical_vector <- c(TRUE, FALSE, TRUE)\n\n# Display the vectors\nnumeric_vector\ncharacter_vector\nlogical_vector\n```\n:::\n\n\n## Creating Sequences\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Using the colon operator for simple sequences\nsequence <- 1:10\nsequence\n\n# You can also create descending sequences\n10:1\n```\n:::\n\n\n## Using seq() for More Control\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# seq() gives you more control over sequences\n# Create a sequence from 1 to 10, incrementing by 2\nseq(from = 1, to = 10, by = 2)\n\n# Create a sequence with exactly 5 equally-spaced values between 1 and 10\nseq(1, 10, length.out = 5)\n```\n:::\n\n\n## Repeating Values with rep()\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Repeat a single value multiple times\nrep(5, times = 3)\n\n# Repeat an entire vector multiple times\nrep(c(1, 2), times = 3)\n\n# Repeat each element multiple times before moving to the next\nrep(c(1, 2), each = 3)\n```\n:::\n\n\n## Vector Operations\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R performs operations element-wise on vectors\nx <- c(1, 2, 3, 4, 5)\ny <- c(10, 20, 30, 40, 50)\n\n# Element-wise addition\nx + y\n\n# Element-wise multiplication\nx * y\n\n# Element-wise exponentiation\nx^2\n\n# You can also perform operations with a single value (vectorization)\nx + 10\nx * 2\n```\n:::\n\n\n# Categorical/Factor Vectors (Factors)\n\nFactors are used for categorical variables in R. They store both the values and the levels (categories), which is essential for statistical analysis and plotting. R uses factors to understand categorical variables properly.\n\n## Creating Basic Factors\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a factor from a character vector\ngender <- c(\"Male\", \"Female\", \"Male\", \"Female\", \"Male\")\ngender_factor <- factor(gender)\ngender_factor\n\n# Check the levels (categories)\nlevels(gender_factor)\n\n# See how many observations in each category\ntable(gender_factor)\n```\n:::\n\n\n## Creating Factors with Specific Levels\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# You can specify the order of levels explicitly\n# This is useful when you want a specific order for plotting or analysis\neducation <- c(\"High School\", \"College\", \"Graduate\", \"High School\")\neducation_factor <- factor(education,\n                          levels = c(\"High School\", \"College\", \"Graduate\"))\neducation_factor\n\n# View the levels in the order you specified\nlevels(education_factor)\n```\n:::\n\n\n## Ordered Factors (Ordinal Data)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use ordered = TRUE for ordinal data (categories with a meaningful order)\nsatisfaction <- c(\"Low\", \"Medium\", \"High\", \"Medium\", \"Low\")\nsatisfaction_ordered <- factor(satisfaction,\n                               levels = c(\"Low\", \"Medium\", \"High\"),\n                               ordered = TRUE)\nsatisfaction_ordered\n\n# Notice the < signs indicating the order\nprint(satisfaction_ordered)\n```\n:::\n\n\n## Factor Operations and Summaries\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get frequency counts\ntable(gender_factor)\n```\n:::\n\n\n## Converting Between Data Types\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert factor back to character\nas.character(gender_factor)\n\n# Convert to numeric (gives you the underlying level numbers, not always useful)\nas.numeric(gender_factor)\n\n# Be careful: converting numeric to factor\nage_values <- c(25, 30, 35, 25, 40, 30)\nage_factor <- factor(age_values)\nage_factor  # Notice it treats each unique number as a separate category\n```\n:::\n\n\n## Grouping Continuous Data into Categories\n\n### Method 1: Using cut() Function\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# cut() is ideal for dividing continuous data into intervals\nages <- c(22, 25, 30, 35, 40, 45, 50, 55, 60, 65)\n\nage_categories <- cut(ages,\n                      breaks = c(0, 30, 50, 100),  # Define the breakpoints\n                      labels = c(\"Young\", \"Middle\", \"Senior\"),  # Label each interval\n                      include.lowest = TRUE)  # Include the lowest value in the first interval\nage_categories\n\n# Check the distribution\ntable(age_categories)\n```\n:::\n\n\n### Method 2: Using ifelse() for Custom Grouping\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ifelse() gives you more control over custom conditions\nages <- c(22, 25, 30, 35, 40, 45, 50, 55, 60, 65)\n\nage_groups_custom <- ifelse(ages < 30, \"Young\",\n                            ifelse(ages < 50, \"Middle\", \"Senior\"))\n\n# Convert to an ordered factor\nage_groups_factor <- factor(age_groups_custom,\n                            levels = c(\"Young\", \"Middle\", \"Senior\"),\n                            ordered = TRUE)\nage_groups_factor\n\n# View the distribution\ntable(age_groups_factor)\nsummary(age_groups_factor)\n```\n:::\n\n\n## Why Use Factors?\n\nFactors are essential because they:\n\n- Help R recognize categorical data in statistical models (e.g., ANOVA, regression)\n- Control the order of categories in plots and tables\n- Store data more efficiently than character strings\n- Prevent typos from creating unintended new categories\n\n# R Objects\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Each object can be saved into the R environment (the workspace here)\n#   You can save the results of a function call to a variable of any name\nMyObject = print(x = 10)\nclass(MyObject)\n\n# You can view the objects you have saved in the Environment tab in RStudio\n# Or type their name\nMyObject\n\n# There are literally thousands of types of objects in R (you can create them),\n#   but for our course we will mostly be working with data frames (more later)\n\n# The process of saving the results of a function to a variable is called \n#   assignment. There are several ways you can assign function results to \n#   variables:\n\n# The equals sign takes the result from the right-hand side and assigns it to\n#   the variable name on the left-hand side:\nMyObject = print(x = 10)\n\n# The <- (Alt \"-\" in RStudio) functions like the equals (right to left)\nMyObject2 <- print(x = 10)\n\nidentical(MyObject, MyObject2)\n\n# The -> assigns from left to right:\nprint(x = 10) -> MyObject3\n\nidentical(MyObject, MyObject2, MyObject3)\n\n# Best practice: Use <- for assignment (more explicit)\n# Use = only for function arguments\n```\n:::\n\n\n# Working with Data Structures\n\n## Lists\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Lists can contain elements of different types\nmy_list <- list(\n  name = \"John\",\n  age = 30,\n  scores = c(85, 90, 78),\n  passed = TRUE\n)\n\n# Accessing list elements\nmy_list$name\nmy_list[[\"age\"]]\nmy_list[[3]]\n\n# Lists are very flexible and useful for complex data structures\n```\n:::\n\n\n## Matrices\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Matrices are 2-dimensional arrays with the same data type\nmy_matrix <- matrix(1:12, nrow = 3, ncol = 4)\nmy_matrix\n\n# Creating matrices from vectors\nmatrix(c(1,2,3,4,5,6), nrow = 2, ncol = 3)\n\n# Matrix operations\nmatrix1 <- matrix(1:4, nrow = 2)\nmatrix2 <- matrix(5:8, nrow = 2)\nmatrix1 + matrix2\nmatrix1 * matrix2  # Element-wise multiplication\n```\n:::\n\n\n# Importing and Exporting Data\n\n-   A data frame is an R object that stores data in a rectangular (table) format.\n    Each column represents a variable and can be of different types (e.g., numeric, character, factor).\n    Each row represents an observation or case.\n\n-   We will start by importing data from a comma-separated values (csv) file.\n\n-   We will use the read.csv() function.\n    Here, the argument `stringsAsFactors = FALSE` prevents R from automatically converting character strings into factors (categorical variables), giving us more control over data types\n\n-   We can use the `here::here()` function to create reliable file paths that work across different operating systems and project structures.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# You can also set the working directory using setwd().\n# For example, to set it to your home folder:\n# setwd(\"~\")\n\ngetwd()  # Get current working directory\ndir()    # List files in current directory\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The following might give an error if the file path is not correct from your current directory:\nHeightsData = read.csv(file = \"heights.csv\",\n                       stringsAsFactors = FALSE)\nHeightsData\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note: Windows users need to use either forward slashes (/) or\n# double backslashes (\\\\) in file paths. Single backslashes (\\) don't work in R.\n# Example: \"C:/Users/name/file.csv\" or \"C:\\\\Users\\\\name\\\\file.csv\"\n\n# To view your data in RStudio, you can either:\n# 1) Double-click the data frame in the Environment tab, or\n# 2) Use the View() function\n# View(HeightsData)\n\n# You can access individual variables (columns) using the $ operator:\nHeightsData$ID\n\n# To read SPSS files, we need the foreign package.\n# The foreign package comes pre-installed with R (no need to use install.packages()).\nlibrary(foreign)\n\n# The read.spss() function imports an SPSS file.\n# Setting to.data.frame = TRUE converts it to an R data frame (rather than a list)\nWideData = read.spss(file = \"wide.sav\", \n                     to.data.frame = TRUE)\nWideData\n```\n:::\n\n\n# Working with Data Frames\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data frames are the most common data structure for statistical analysis\n# They are like spreadsheets with rows (observations) and columns (variables)\n\n# Basic data frame operations\ndim(HeightsData)        # Dimensions (rows, columns)\nnrow(HeightsData)       # Number of rows\nncol(HeightsData)       # Number of columns\nnames(HeightsData)      # Column names\nstr(HeightsData)        # Structure of the data frame\nhead(HeightsData)       # First 6 rows\ntail(HeightsData)       # Last 6 rows\nsummary(HeightsData)    # Summary statistics\n\n# Accessing data frame elements\nHeightsData[1, 2]       # Row 1, Column 2\nHeightsData[1:5, ]      # Rows 1-5, all columns\nHeightsData[, \"ID\"]     # All rows, column named \"ID\"\nHeightsData$ID          # Same as above (preferred method)\n\n# Subsetting data frames\nsubset(HeightsData, HeightIN > 70)\nHeightsData[HeightsData$HeightIN > 70, ]\n```\n:::\n\n\n## Exercise\n\n-   Obtain the following information from WideData\n    -   Dimensions (rows, columns)\n    -   Number of rows\n    -   Number of columns\n    -   Column names\n    -   Structure of the data frame\n    -   First 6 rows\n    -   Last 6 rows\n    -   Summary statistics\n\n# Merging R data frame objects\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The WideData and HeightsData have the same set of ID numbers.\n# We can use the merge() function to merge them into a single data frame.\n# Here, x is the name of the left-side data frame and y is the name of the\n# right-side data frame. The arguments by.x and by.y specify the variable(s)\n# by which we will merge:\nAllData = merge(x = WideData, y = HeightsData, by.x = \"ID\", by.y = \"ID\")\nAllData\n\n## Method 2: Use dplyr method (the pipe operator |> can be typed using Ctrl+Shift+M on Windows or Cmd+Shift+M on Mac)\nlibrary(dplyr)\nWideData |> \n  left_join(HeightsData, by = \"ID\")\n\n# Different types of joins:\n# left_join(): Keep all rows from left table\n# right_join(): Keep all rows from right table  \n# inner_join(): Keep only rows that appear in both tables\n# full_join(): Keep all rows from both tables\n```\n:::\n\n\n# Transforming Wide to Long\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sometimes, certain packages require repeated measures data to be in a long\n# format (where each measurement is on a separate row rather than in separate columns). \n\nlibrary(dplyr) # contains variable selection\n\n## Wrong Way (pivoting DV and Age separately creates unwanted combinations)\nAllDataLong <- AllData |> \n  tidyr::pivot_longer(starts_with(\"DVTime\"), names_to = \"DV\", values_to = \"DV_Value\") |> \n  tidyr::pivot_longer(starts_with(\"AgeTime\"), names_to = \"Age\", values_to = \"Age_Value\") \n\nOnePerson <- AllDataLong  |> \n  filter(ID == \"1\")\n\nOnePerson\n\n## Correct Way (pivot both variables together, then separate and widen properly)\nAllDataLong <- AllData |> \n  tidyr::pivot_longer(c(starts_with(\"DVTime\"), starts_with(\"AgeTime\"))) |> \n  tidyr::separate(name, into = c(\"Variable\", \"Time\"), sep = \"Time\") |> \n  tidyr::pivot_wider(names_from = \"Variable\", values_from = \"value\") -> AllDataLong\n\nOnePerson <- AllDataLong |> \n  filter(ID == \"1\")\nOnePerson\n\n# Understanding data reshaping:\n# Wide format: Each time point has its own column\n# Long format: Time points are in rows, with a time variable\n```\n:::\n\n\n## Exercise\n\n### Practice: Wide to Long with dplyr\n\nIn this exercise, you will practice reshaping repeated-measures data from wide format to long format using a dplyr pipeline (with tidyr functions).\n\n1.  Create the small wide data frame shown below.\n2.  Reshape it to long format so that you have four columns: `id`, `time`, `dv`, and `age`.\n3.  Compute the mean of `dv` by `time` as a verification step.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(dplyr)\nlibrary(tidyr)\n\n# 1) Start from a small wide toy data set\ntoy_wide <- tibble::tribble(\n  ~id, ~dv_time1, ~dv_time2, ~dv_time3, ~age_time1, ~age_time2, ~age_time3,\n   1,        10,        12,        15,         20,         21,         22,\n   2,         8,        11,        11,         19,         20,         21,\n   3,        14,        13,        16,         21,         22,         23\n)\n\n# 2) YOUR TURN: Convert to long using a single dplyr pipeline\n#    Goal columns: id, time (1/2/3), dv, age\n#    Hints:\n#      - Use pivot_longer() on both dv_ and age_ columns together\n#      - Separate the column name into variable (dv/age) and time (1/2/3)\n#      - Use pivot_wider() to spread variable back into dv and age columns\n```\n:::\n\n\n#### Optional solution\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntoy_long <- toy_wide |> \n  pivot_longer(\n    cols = c(starts_with(\"dv_\"), starts_with(\"age_\")),\n    names_to = \"name\",\n    values_to = \"value\"\n  ) |> \n  separate(name, into = c(\"variable\", \"time\"), sep = \"_time\") |> \n  pivot_wider(names_from = variable, values_from = value) |> \n  mutate(time = as.integer(time))\n\ntoy_long\n\ntoy_long |> \n  group_by(time) |> \n  summarize(mean_dv = mean(dv, na.rm = TRUE), .groups = \"drop\")\n```\n:::\n\n\n# Data Manipulation with dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The dplyr package provides an intuitive set of functions for data manipulation\n\n# Select columns\nAllData |> \n  select(ID, starts_with(\"DV\"))\n\n# Filter rows\nAllData |> \n  filter(ID < 5)\n\n# Arrange rows\nAllData |> \n  arrange(ID)\n\n# Create new variables\nAllData |> \n  mutate(\n    DV_avg = (DVTime1 + DVTime2 + DVTime3) / 3,\n    DV_range = DVTime3 - DVTime1\n  )\n\n# Group and summarize\nAllDataLong |> \n  group_by(Time) |> \n  summarize(\n    mean_DV = mean(DV, na.rm = TRUE),\n    sd_DV = sd(DV, na.rm = TRUE),\n    n = n()\n  )\n```\n:::\n\n\n# Gathering Descriptive Statistics\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The psych package provides convenient functions for computing descriptive statistics.\n## If you haven't installed it yet, run: install.packages(\"psych\")\nlibrary(psych)\n\n# Use describe() to get comprehensive descriptive statistics for all variables:\nDescriptivesWide = describe(AllData)\nDescriptivesWide\n\nDescriptivesLong = describe(AllDataLong)\nDescriptivesLong\n\n# Use describeBy() to compute descriptive statistics separately for each group:\nDescriptivesLongID = describeBy(AllDataLong, group = AllDataLong$ID)\nDescriptivesLongID\n\n# Basic descriptive statistics without packages:\nmean(AllDataLong$DV, na.rm = TRUE)\nmedian(AllDataLong$DV, na.rm = TRUE)\nsd(AllDataLong$DV, na.rm = TRUE)\nvar(AllDataLong$DV, na.rm = TRUE)\nmin(AllDataLong$DV, na.rm = TRUE)\nmax(AllDataLong$DV, na.rm = TRUE)\nquantile(AllDataLong$DV, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)\n```\n:::\n\n\n# Transforming Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# You can transform data by creating new variables. \nAllDataLong$AgeC = AllDataLong$Age - mean(AllDataLong$Age)\n\n# You can also use functions to create new variables. Here we create new terms\n#   using the function for significant digits:\nAllDataLong$AgeYear = signif(x = AllDataLong$Age, digits = 2)\nAllDataLong$AgeDecade = signif(x = AllDataLong$Age, digits = 1)\nhead(AllDataLong)\n\n# Common data transformations:\n# Centering: subtract mean\n# Standardizing: (x - mean) / sd\n# Log transformation: log(x)\n# Square root: sqrt(x)\n# Recoding: ifelse(condition, value_if_true, value_if_false)\n\n# Example: Create standardized variables\nAllDataLong$DV_z <- scale(AllDataLong$DV)\nAllDataLong$Age_z <- scale(AllDataLong$Age)\n```\n:::\n\n\n# Basic Plotting\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R has excellent plotting capabilities\n\n# Base R plotting\nhist(AllDataLong$DV, main = \"Distribution of DV\", xlab = \"DV Values\")\nboxplot(DV ~ Time, data = AllDataLong, main = \"DV by Time\")\nplot(AllDataLong$Age, AllDataLong$DV, main = \"DV vs Age\")\n\n# Using ggplot2 (more modern and flexible)\n# If you have not install the package yet, type in install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\n# Histogram\nggplot(AllDataLong, aes(x = DV)) +\n  geom_histogram(bins = 30) +\n  labs(title = \"Distribution of DV\", x = \"DV Values\", y = \"Count\")\n\n# Boxplot\nggplot(AllDataLong, aes(x = Time, y = DV)) +\n  geom_boxplot() +\n  labs(title = \"DV by Time\")\n\n# Scatter plot\nggplot(AllDataLong, aes(x = Age, y = DV)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  labs(title = \"DV vs Age\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhw0_feedback <- read.csv(here::here(\"teaching/2025-01-13-Experiment-Design/Lecture01\", \"hw0_feedback.csv\"))\ntable(hw0_feedback$Feedback)\n```\n:::\n\n\n# Control Structures\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Conditional statements (if-else)\nx <- 10\nif (x > 5) {\n  print(\"x is greater than 5\")\n} else {\n  print(\"x is less than or equal to 5\")\n}\n\n## Alternative method using ifelse() function (vectorized)\nifelse(x > 5,\n       print(\"x is greater than 5\"),\n       print(\"x is less than or equal to 5\"))\n\n# For loops (repeat code a specific number of times)\nfor (i in 1:5) {\n  print(paste(\"Iteration\", i))\n}\n\n# While loops (repeat code while a condition is TRUE)\ni <- 1\nwhile (i <= 5) {\n  print(paste(\"While iteration\", i))\n  i <- i + 1\n}\n\n# Apply functions (more efficient and \"R-like\" than explicit loops)\nnumbers <- 1:10\nsapply(numbers, function(x) x^2)  # Returns a vector\nlapply(numbers, function(x) x^2)  # Returns a list\n```\n:::\n\n\n# Working with Missing Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R uses NA (Not Available) to represent missing data\n# Check for missing values in a variable\nis.na(AllDataLong$DV)              # Returns TRUE/FALSE for each value\nsum(is.na(AllDataLong$DV))        # Count the number of missing values\ncomplete.cases(AllDataLong)        # Check which rows have no missing data\n\n# Remove rows that contain any missing data\nAllDataLong_complete <- na.omit(AllDataLong)\n# Alternative method (same result):\nAllDataLong_complete <- AllDataLong[complete.cases(AllDataLong), ]\n\n# Replace missing values with the mean (simple imputation)\nAllDataLong$DV_imputed <- ifelse(is.na(AllDataLong$DV), \n                                 mean(AllDataLong$DV, na.rm = TRUE), \n                                 AllDataLong$DV)\n```\n:::\n\n\n# Best Practices and Tips\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Always use meaningful variable names\n# 2. Comment your code\n# 3. Use consistent formatting\n# 4. Check your data after importing\n# 5. Save your work regularly\n# 6. Use version control (Git)\n# 7. Write reproducible code\n# 8. Use packages for common tasks\n# 9. Learn to use help documentation\n# 10. Practice regularly!\n\n# Useful keyboard shortcuts in RStudio:\n# Ctrl+Enter (Cmd+Enter on Mac): Run the current line or selected code\n# Ctrl+Shift+Enter (Cmd+Shift+Enter on Mac): Run the entire script\n# Ctrl+Shift+M (Cmd+Shift+M on Mac): Insert the pipe operator |>\n# Ctrl+Shift+C (Cmd+Shift+C on Mac): Comment or uncomment selected lines\n# Ctrl+Shift+R (Cmd+Shift+R on Mac): Insert a code section header\n```\n:::\n\n\n# Getting Help\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R has excellent help documentation\n?mean                    # Help for a function\n??\"regression\"          # Search for functions containing \"regression\"\nhelp(mean)              # Same as ?mean\nexample(mean)           # Run examples for a function\n\n# Online resources:\n# - R Documentation: https://www.rdocumentation.org/\n# - Stack Overflow: https://stackoverflow.com/questions/tagged/r\n# - R-bloggers: https://www.r-bloggers.com/\n# - RStudio Community: https://community.rstudio.com/\n\n# Installing and loading packages\ninstall.packages(\"package_name\")  # Install once\nlibrary(package_name)             # Load each session\nrequire(package_name)             # Alternative to library()\n```\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}