{
  "hash": "28a327c018687d322a413ebd68688177",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Error Handling in R\"\nsubtitle: \"How to handling error of simulation study and functions in R\"\ndescription: \"Error handling is important for simulation study\"\nauthor: 'Jihong Zhang'\ndate: 'August 31 2024'\nsidebar: false\ncategories:\n  - R\n  - Simulation\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  error: true\nformat: \n  html: \n    code-fold: false\n    code-summary: 'Click to see the code'\n    number-sections: true\nbibliography: references.bib\n---\n\n\n\n> This blog is based on @andersonErrorHandlingGeneration2020 and @wickhamConditionsAdvanced2024\n\n## What is Error in R?\n\nIn R, errors are signaled, or thrown, by `stop()` or `stopifnot()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstop(\"Something erroneous has occurred!\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in eval(expr, envir, enclos): Something erroneous has occurred!\n```\n\n\n:::\n\n```{.r .cell-code}\nstopifnot(5 < 0)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: 5 < 0 is not TRUE\n```\n\n\n:::\n:::\n\n\n\n`stopifnot()` is basically a wrap-up function of `if`-condition and `stop` to detect if any of the expressions are not all TRUE.\n\nSometimes, error messages are meaningful and deliberately created/controlled by function authors while it is meaningless and subjected to be controlled by R users. Here are some scenairos:\n\n**Example 1** **- Uncontrolled error**: You want to ran a `for` iteration while there is some error message in some iterations. The error message contains nothing but the stopping signals from data analysis for certain iterations. This type of error message make not much sense to understanding why this error occur.\n\n**Example 2 - Controlled error**: You are using a function inappropriately and this function throws you some message. If the function is well coded, the error message does tell you the \"**Problem statement**\" using `must` or `can't`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::nth(1:10, 1:2)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `dplyr::nth()`:\n! `n` must have size 1, not size 2.\n```\n\n\n:::\n\n```{.r .cell-code}\nas_vector(environment())\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in as_vector(environment()): could not find function \"as_vector\"\n```\n\n\n:::\n:::\n\n\n\nSome functions also provide hints when error occurs:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::filter(iris, Species = \"setosa\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `dplyr::filter()`:\n! We detected a named input.\nℹ This usually means that you've used `=` instead of `==`.\nℹ Did you mean `Species == \"setosa\"`?\n```\n\n\n:::\n:::\n\n\n\n## Functions for error handling in R\n\n### Use `try` to ignore errors\n\nWith the `try` function, you can \"hide\" or ignore error signals to continue the execution:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Function without try\nfun0 <- function() {\n  x <- b\n  x <- 3\n  print(x)\n}\nfun0()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in fun0(): object 'b' not found\n```\n\n\n:::\n\n```{.r .cell-code}\n## Function with try\nfun1 <- function() {\n  try(x <- b)\n  x <- 3\n  print(x)\n}\nfun1()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in try(x <- b) : object 'b' not found\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n## Multiple errors in one function\noptions(error = function() traceback(3))\nfun1 <- function() {\n  try(x <- b1) # This will throw error but will keep the execution\n  try(x <- 3) # This will not throw error and will execute the code normally\n  print(x)\n  x <- b2 # This will also throw error but will stop the execution\n  print(x)\n}\nfun1()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in try(x <- b1) : object 'b1' not found\n[1] 3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError in fun1(): object 'b2' not found\n```\n\n\n:::\n:::\n\n\n\nThe function with `try` does not stop executing the rest of the syntax after error occurs (`x <- b`). However, there is one issue of `try()`: it only ignores single error message at once and you have to know where the error comes from beforehand.\n\nIn practice, you can ignore error when running the simulation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (x in list(1, 2, \"not a number\")) {\n  y <- 3*x\n  print(paste0(\"3x= \", y))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3x= 3\"\n[1] \"3x= 6\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError in 3 * x: non-numeric argument to binary operator\n```\n\n\n:::\n\n```{.r .cell-code}\nfor (x in list(1, 2, \"not a number\")) {\n  # when x iterate over thirt element, try() ignore the error\n  # and still keep y = 2\n  try(y  <- 3*x, silent = TRUE) \n  try(print(paste0(\"3x= \", y)))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3x= 3\"\n[1] \"3x= 6\"\n[1] \"3x= 6\"\n```\n\n\n:::\n:::\n\n\n\nIf you want to assign b to x if b is available and assign NA to x if b is unavailable, you can:\n\n1.  Use `if` condition to detect whether b is available or not;\n2.  Use `tryCatch()` to use condition name (error, warning) as parameter\n\n### Use `tryCatch` to handle errors\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# when b is unavailable\ntryCatch({\n  x <- b\n}, error = function(e) {x <<- NA})\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# when b is available\nb <- 3\ntryCatch({\n  x <- b\n}, error = function(e) {x <<- NA})\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\nThe `tryCatch()` will catch the error condition (warning) and execute another function you defined (`error = function(e)` in the example). Note that if you want to change x's value in `error` function when `x<-b` has error, you need to use `<<-` assign symbol to transfer x value into [global environment](https://adv-r.hadley.nz/environments.html).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}