{
  "hash": "13d90a0d3bca91dc507b4355a406e5cf",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: How to use Julia in Quarto\nauthor: Jihong Zhang\ndate: Mar 10 2024\ncategories:\n  - Julia\n  - Quarto\ntoc: true\nnumber-sections: true\nexecute:\n  eval: true\n  output: false\nformat:\n  html:\n    code-summary: Code\n    code-fold: false\n    code-line-numbers: false\n---\n\n## Previous posts\n\nThis [post](../../posts/2021-08-30-gradient-descent-via-julia/index.md) illustrates how to use Julia to create a gradient descent algorithm. What has not been introduced, however, is how to perform the data analysis using Julia in Quarto. This post will illustrate the workflow step by step.\n\n## Initial Setup\n\nFirst of all, refer to this [Quarto.org](https://quarto.org/docs/computations/julia.html), [JuliaHub](https://help.juliahub.com/juliahub/stable/tutorials/quarto/), and Patrick Altmeyer's [post](https://www.paltmeyer.com/blog/posts/tips-and-tricks-for-using-quarto-with-julia/). The first step is to install following components:\n\n1.  IJulia\n2.  Revise.jl\n3.  Jupyter Cache\n\n``` {.bash filename=\"Terminal\"}\nusing Pkg\nPkg.add(\"IJulia\")\nusing IJulia\nnotebook()\n```\n\nSecond, when you create the new quarto document, make sure the yaml header contains the \"jupyter\" setting. For example, the yaml of this post is:\n\n``` yaml\ntitle: 'How to use Julia in Quarto'\nauthor: 'Jihong Zhang'\ndate: 'Mar 10 2024'\ncategories:\n  - Julia\n  - Quarto\nformat: \n  html: \n    code-summary: 'Code'\n    code-fold: false\n    code-line-numbers: false\njupyter: julia-1.6\n```\n\nAfter the installation, you should be able to run the julia code in quarto.\n\n::: {#1279ae1a .cell execution_count=1}\n``` {.julia .cell-code}\nprint(\"Hello World!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World!\n```\n:::\n:::\n\n\n## Import dataset\n\n::: {#b2597e89 .cell execution_count=2}\n``` {.julia .cell-code}\n# import packages\nusing DataFrames\nusing CSV\n# load in the diamonds.csv\ndiamonds = DataFrame(CSV.File(\"/Users/jihong/Documents/Projects/website-jihong/notes/2024-03-15-Julia-in-quarto/diamonds.csv\"))\n```\n:::\n\n\n::: {#687a0747 .cell execution_count=3}\n``` {.julia .cell-code}\nfirst(diamonds, 7)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div class=\"data-frame\"><p>7 rows × 10 columns (omitted printing of 1 columns)</p><table class=\"data-frame\"><thead><tr><th></th><th>carat</th><th>cut</th><th>color</th><th>clarity</th><th>depth</th><th>table</th><th>price</th><th>x</th><th>y</th></tr><tr><th></th><th title=\"Float64\">Float64</th><th title=\"String\">String</th><th title=\"String\">String</th><th title=\"String\">String</th><th title=\"Float64\">Float64</th><th title=\"Float64\">Float64</th><th title=\"Int64\">Int64</th><th title=\"Float64\">Float64</th><th title=\"Float64\">Float64</th></tr></thead><tbody><tr><th>1</th><td>0.23</td><td>Ideal</td><td>E</td><td>SI2</td><td>61.5</td><td>55.0</td><td>326</td><td>3.95</td><td>3.98</td></tr><tr><th>2</th><td>0.21</td><td>Premium</td><td>E</td><td>SI1</td><td>59.8</td><td>61.0</td><td>326</td><td>3.89</td><td>3.84</td></tr><tr><th>3</th><td>0.23</td><td>Good</td><td>E</td><td>VS1</td><td>56.9</td><td>65.0</td><td>327</td><td>4.05</td><td>4.07</td></tr><tr><th>4</th><td>0.29</td><td>Premium</td><td>I</td><td>VS2</td><td>62.4</td><td>58.0</td><td>334</td><td>4.2</td><td>4.23</td></tr><tr><th>5</th><td>0.31</td><td>Good</td><td>J</td><td>SI2</td><td>63.3</td><td>58.0</td><td>335</td><td>4.34</td><td>4.35</td></tr><tr><th>6</th><td>0.24</td><td>Very Good</td><td>J</td><td>VVS2</td><td>62.8</td><td>57.0</td><td>336</td><td>3.94</td><td>3.96</td></tr><tr><th>7</th><td>0.24</td><td>Very Good</td><td>I</td><td>VVS1</td><td>62.3</td><td>57.0</td><td>336</td><td>3.95</td><td>3.98</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n## Basic Statistical Modeling\n\nFollowing the previous post, we can easily model a generalized linear regression using `GLM` module:\n\n::: {#bb7a7d2f .cell execution_count=4}\n``` {.julia .cell-code}\nusing GLM\nlm_fit = lm(@formula(price ~ depth), diamonds)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nStatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}}}}, Matrix{Float64}}\n\nprice ~ 1 + depth\n\nCoefficients:\n────────────────────────────────────────────────────────────────────────\n               Coef.  Std. Error      t  Pr(>|t|)  Lower 95%   Upper 95%\n────────────────────────────────────────────────────────────────────────\n(Intercept)  5763.67    740.556    7.78    <1e-14  4312.17    7215.16\ndepth         -29.65     11.9897  -2.47    0.0134   -53.1499    -6.15005\n────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n\nLet's do some more advanced measurement - Factor analysis:\n\n::: {#c49bbed7 .cell execution_count=5}\n``` {.julia .cell-code}\nusing MultivariateStats\n# only sample first 300 cases and four variables\nXtr = diamonds[1:300 , [:x, :y, :z]]\n# with each observation in a column\nXtr = Matrix(Xtr)' # somehow the data matrix has size of (d, n), which is the trasponse of data matrix in R \n# train a one-factor model\nM = fit(FactorAnalysis, Xtr; maxoutdim=1, method=:em)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nFactor Analysis(indim = 3, outdim = 1)\n```\n:::\n:::\n\n\nYou can refer to this [doc](https://multivariatestatsjl.readthedocs.io/en/latest/fa.html) for more details for parameter estimation of factor analysis\n\n::: {#ed3d745c .cell execution_count=6}\n``` {.julia .cell-code}\nloadings(M)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n3×1 Matrix{Float64}:\n 0.8294175777737884\n 0.8157441937709995\n 0.5052202721703143\n```\n:::\n:::\n\n\nLet's quickly compare the results of `lavaan`\n\n``` r\nlibrary(ggplot2)\nlibrary(lavaan)\ndata('diamonds')\nX = diamonds[1:300, c('x', 'y', 'z')]\nfa_model = \"\nF1 =~ x + y + z\n\"\nfit = cfa(fa_model, data = X, std.lv = TRUE)\ncoef(fit)[1:3] # factor loading\n    F1=~x     F1=~y     F1=~z \n0.7802245 0.7673664 0.4752576 \n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}