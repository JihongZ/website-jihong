{
  "hash": "304fb2e6ca356689fdf5c4b6a9fe615f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lecture 12: Principal Components Analysis and Factor Analysis\"\nsubtitle: \"Absolute Model fit and Model Interpretation\"\nauthor: \"Jihong Zhang*, Ph.D\"\ninstitute: | \n  Educational Statistics and Research Methods (ESRM) Program*\n  \n  University of Arkansas\ndate: \"2024-10-09\"\ndate-modified: \"2024-10-11\"\nsidebar: false\nexecute: \n  echo: true\n  warning: false\noutput-location: default\ncode-annotations: below\nhighlight-style: \"nord\"\nformat: \n  uark-revealjs:\n    scrollable: true\n    chalkboard: true\n    embed-resources: false\n    code-fold: false\n    number-sections: false\n    footer: \"ESRM 64503 - Lecture 12: Absolute Model fit and Path Analysis\"\n    slide-number: c/t\n    tbl-colwidths: auto\n    output-file: slides-index.html\n  html: \n    page-layout: full\n    toc: true\n    toc-depth: 2\n    toc-expand: true\n    lightbox: true\n    code-fold: false\n    fig-align: center\nfilters:\n  - quarto\n  - line-highlight\nbibliography: references.bib\n---\n\n\n\n\n## Today's Class\n\n-   Methods for exploratory factor analysis (EFA)\n    - Principal Components-based\n    - Maximum Likelihood-based Exploratory Factor Analysis\n    - Exploratory Structural Equation Modeling\n- Comparisons of CFA and EFA\n- How to do exploratory analyses with CFA\n    - Structure of no items known\n    - Structure of some items known\n\n\n\n\n::: {.cell output-location='default'}\n\n```{.r .cell-code}\nlibrary(ESRM64503)\nlibrary(kableExtra)\nlibrary(tidyverse)\nlibrary(DescTools) # Desc() allows you to quick screen data\nlibrary(lavaan) # Desc() allows you to quick screen data\n# options(digits = 3)\n```\n:::\n\n\n\n\n## The Logic of Exploratory Analyses\n\n- Exploratory analyses attempt to discover hidden structure in data with little to no\nuser input\n    -  Aside from the selection of analysis and estimation\n- The results from exploratory analyses can be misleading\n    -  If data do not meet assumptions of model or method selected\n    -  If data have quirks that are idiosyncratic to the sample selected\n    -  If some cases are extreme relative to others\n    -  If constraints made by analysis are implausible\n- Sometimes, exploratory analyses are needed\n    -  Must construct an analysis that capitalizes on the known features of data\n    -  There are better ways to conduct such analyses\n- Often, exploratory analyses are not needed\n    -  But are conducted anyway – see a lot of reports of scale development that start with the idea that a construct has a certain number of dimensions\n\n# Advanced matrix operations\n\n## Matrix Orthogonality\n\n-   A square matrix $\\Lambda$ is said to be orthogonal if:\n\n$$\n\\mathbf{\\Lambda\\Lambda^T = \\Lambda^T\\Lambda = I}\n$$\n\n-   Orthogonal matrices are characterized by two properties\n    1. The dot product of all row vector multiples is the zero vector \n        - Meaning vectors are orthogonal (or uncorrelated)\n    2. For each row vector, the sum of all elements is one\n        - Meaning vectors are “normalized”\n\n-   The matrix above is also called **orthonormal**\n    -   The diagonal is equal to 1 (each vector has a unit length)\n    \n-   Orthonormal matrices are used in principal components and exploratory factor analysis    \n\n\n## Eigenvalues and Eigenvectors\n\n-   A square matrix $\\mathbf{\\Sigma}$ can be decomposed into a set of eigenvalues $\\mathbf{\\lambda}$ and a set of eigenvectors $e$:\n\n$$\n\\mathbf{\\Sigma e} = \\lambda \\mathbf{e}\n$$\n\n-   Each eigenvalue has a corresponding eigenvector\n    -   The number equal to the number of rows/columns of $\\mathbf{\\Sigma}$\n    \n-   Principal components analysis uses eigenvalues and eigenvectors to reconfigure data\n\n## Example: Eigenvalues and Eigenvectors\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Correlation matrix of SAR sR\nsat_corrmat = cor(dataSAT[, c(\"SATV\", \"SATM\")])\n\n## eignvalues and eigenvectors of correlation matrix:\nsat_eigen = eigen(x = sat_corrmat, symmetric = TRUE)\nsat_eigen$values # eigenvalues\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.7752238 0.2247762\n```\n\n\n:::\n\n```{.r .cell-code}\nsat_eigen$vectors # eigenvectors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]       [,2]\n[1,] 0.7071068 -0.7071068\n[2,] 0.7071068  0.7071068\n```\n\n\n:::\n:::\n\n\n\n\n-   In our SAT sample, the two eigenvalues obtained were:\n\n$$\n\\lambda_1 = 1.775; \n\\lambda_2 = 0.224 \\\\\n$$\n\n- The two eigenvectors obtained were:\n\n$$\n\\mathbf{e}_1 = \\begin{bmatrix}0.707 \\\\ 0.707\\end{bmatrix};\n\\mathbf{e}_2 = \\begin{bmatrix}-0.707 \\\\ 0.707\\end{bmatrix}\n$$\n\n-   These terms will have much greater meaning principal components analysis\n\n## Spectral Decomposition\n\n-   Using the eigenvalues and eigenvectors, we can reconstruct the original matrix using a spectral decomposition:\n\n$$\n\\mathbf{\\Sigma =}\\sum_{i=1}^{p} \\lambda_i\\mathbf{e}_i \\mathbf{e}_i^T\n$$\n\nwhere i is the index of row/column of square matrix\n\n-   For our example, we can get back to our 2*2 original matrix:\n\n$$\n\\mathbf{R}_1 = \\lambda_1 \\mathbf{e}_i \\mathbf{e}_i^T = 1.775 \\begin{bmatrix}0.707 \\\\ 0.707\\end{bmatrix} \\begin{bmatrix}0.707 & 0.707\\end{bmatrix} = \\begin{bmatrix}0.890 & 0.890\\\\ 0.890 & 0.890\\end{bmatrix}\n$$\n$$\n\\begin{align}\n\\mathbf{R}_2 &= \\mathbf{R}_1 +\\lambda_1 \\mathbf{e}_i \\mathbf{e}_i^T \\\\\n&= \\begin{bmatrix}0.890 & 0.890\\\\ 0.890 & 0.890\\end{bmatrix}\n + 0.224 \\begin{bmatrix}-0.707 \\\\ 0.707\\end{bmatrix} \\begin{bmatrix}-0.707 & 0.707\\end{bmatrix} \\\\\n&= \\begin{bmatrix}1.000 & 0.780\\\\ 0.780 & 1.000 \\end{bmatrix}\n\\end{align}\n$$",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}