{
  "hash": "e26ec2075390fa55c072ee5955382a87",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lecture 02: R Objects, Functions, Packages\"\nsubtitle: \"Getting Started\"\nauthor: \"Jihong Zhang*, Ph.D\"\ninstitute: | \n  Educational Statistics and Research Methods (ESRM) Program*\n  \n  University of Arkansas\ndate: \"2024-10-09\"\ndate-modified: \"2024-10-11\"\nsidebar: false\nexecute: \n  echo: true\n  warning: false\n  eval: true\noutput-location: default\ncode-annotations: below\nhighlight-style: \"nord\"\nformat: \n  uark-revealjs:\n    scrollable: true\n    chalkboard: true\n    embed-resources: false\n    code-fold: false\n    number-sections: false\n    footer: \"ESRM 64503 - Lecture 02: Object/Function/Package\"\n    slide-number: c/t\n    tbl-colwidths: auto\n    output-file: slides-index.html\n---\n\n\n\n## Today's Class\n\n1.  R objects\n    1.  Data types\n    2.  Vectors\n    3.  Coercion\n    4.  Not available (NA)\n    5.  Sorting\n    6.  Vector arithmetics\n    7.  Indexing\n\n\n# R Objects\n\n## Data Types\n\n1.  Variables is one most frequently used R object. Variables can be of different types. Some examples of variables are:\n    1.  `character`\n    2.  `numeric`\n    3.  `logical`\n    4.  `data.frame`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"dslabs\")\nclass(\"Hello World\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(murders)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\n### Data frames\n\n1.  The most common way of storing a dataset in R is in a *data frame*.\n\n2.  we can think of a data frame as a table with **rows** representing **observations** and the different **variables** reported for each observation defining the **columns**.\n\n3.  Most pre-built datasets are stored in R packages For example, you can access the `murders` by loading the `dslabs` package.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(dslabs)\n    class(murders)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"data.frame\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n4.  Some helpful functions that you can find out more about the structure of data frame.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    str(murders) # structure of the data frame\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    'data.frame':\t51 obs. of  5 variables:\n     $ state     : chr  \"Alabama\" \"Alaska\" \"Arizona\" \"Arkansas\" ...\n     $ abb       : chr  \"AL\" \"AK\" \"AZ\" \"AR\" ...\n     $ region    : Factor w/ 4 levels \"Northeast\",\"South\",..: 2 4 4 2 4 4 1 2 2 2 ...\n     $ population: num  4779736 710231 6392017 2915918 37253956 ...\n     $ total     : num  135 19 232 93 1257 ...\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    head(murders)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n           state abb region population total\n    1    Alabama  AL  South    4779736   135\n    2     Alaska  AK   West     710231    19\n    3    Arizona  AZ   West    6392017   232\n    4   Arkansas  AR  South    2915918    93\n    5 California  CA   West   37253956  1257\n    6   Colorado  CO   West    5029196    65\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    tail(murders)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n               state abb        region population total\n    46       Vermont  VT     Northeast     625741     2\n    47      Virginia  VA         South    8001024   250\n    48    Washington  WA          West    6724540    93\n    49 West Virginia  WV         South    1852994    27\n    50     Wisconsin  WI North Central    5686986    97\n    51       Wyoming  WY          West     563626     5\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    murders$population # access the specific column\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n     [1]  4779736   710231  6392017  2915918 37253956  5029196  3574097   897934\n     [9]   601723 19687653  9920000  1360301  1567582 12830632  6483802  3046355\n    [17]  2853118  4339367  4533372  1328361  5773552  6547629  9883640  5303925\n    [25]  2967297  5988927   989415  1826341  2700551  1316470  8791894  2059179\n    [33] 19378102  9535483   672591 11536504  3751351  3831074 12702379  1052567\n    [41]  4625364   814180  6346105 25145561  2763885   625741  8001024  6724540\n    [49]  1852994  5686986   563626\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    names(murders) # variables' name\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"state\"      \"abb\"        \"region\"     \"population\" \"total\"     \n    ```\n    \n    \n    :::\n    :::\n\n\n\n------------------------------------------------------------------------\n\n### Vectors\n\n1.  The object `murders$population` is not one number but several. We call these types of objects ***vectors***.\n\n2.  A single number is technically a vector of length 1, but in general we use the term vectors to refer to objects with several entries.\n\n3.  Some helpful functions that tells you more about the vector\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pop <- murders$population\n    length(pop) # how many entries are in the vector\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 51\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    class(pop) # one vector has only have one data types (except list)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"numeric\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    class(murders$state)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"character\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n------------------------------------------------------------------------\n\n4.  One special vector is **logical** vector. It must be either `TRUE` or `FALSE`:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    z <- c(2, 3, 7, 8, 10)\n    LargerThanFive <- (z > 5)\n    LargerThanFive\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] FALSE FALSE  TRUE  TRUE  TRUE\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    class(LargerThanFive)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"logical\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    EqualToSeven <- (z == 7)\n    print(EqualToSeven)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] FALSE FALSE  TRUE FALSE FALSE\n    ```\n    \n    \n    :::\n    :::\n\n\n\n    Here, `>` is a relational operator. You can use the relational operator like, `<`, `<=`, `>=`, `==` (is equal to), `!=` (is not equal to) to elementwise compare variables in vectors. `identical` function could be use to determine whether two objects are the same.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    identical(z, c(2, 3, 7, 8, 10))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] TRUE\n    ```\n    \n    \n    :::\n    :::\n\n\n\n------------------------------------------------------------------------\n\n### Factors\n\n1.  Factors are another type of vectors that are useful for storing categorical data with a few levels.\n\n2.  For example, in `murders` dataset, we can see there are only 4 regions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(murders$region)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(murders$region)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Northeast\"     \"South\"         \"North Central\" \"West\"         \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(murders$region)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    Northeast         South North Central          West \n            9            17            12            13 \n```\n\n\n:::\n:::\n\n\n\n3.  In the background, R stores these levels as integers and keeps a map to keep track of the labels.\n\n------------------------------------------------------------------------\n\n4.  We can manipulate the order of the factor based on another varaible using `reorder` function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregion <- murders$region\nlevels(region)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Northeast\"     \"South\"         \"North Central\" \"West\"         \n```\n\n\n:::\n\n```{.r .cell-code}\nvalue <- murders$total # the total number of murder\nregion_ordered <- reorder(region, value, FUN = sum)\nlevels(region_ordered)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Northeast\"     \"North Central\" \"West\"          \"South\"        \n```\n\n\n:::\n\n```{.r .cell-code}\nsouth_as_reference <- factor(region, levels = c(\"South\", \"Northeast\", \"North Central\", \"West\"))\nlevels(south_as_reference)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"South\"         \"Northeast\"     \"North Central\" \"West\"         \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nmurders |> \n    group_by(region) |> \n    summarise(total_value = sum(total))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  region        total_value\n  <fct>               <dbl>\n1 Northeast            1469\n2 South                4195\n3 North Central        1828\n4 West                 1911\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\n### List\n\n1.  Data frames are a special case of **lists**. Lists are useful because you can store any combination of different types. You can create a list using the list function like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecord <- list(name = \"John Doe\",\n             student_id = 1234,\n             grades = c(95, 82, 91, 97, 93),\n             final_grade = \"A\")\n```\n:::\n\n\n\n2.  This list includes a character, a number, a vector with five numbers, and another character.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecord\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$name\n[1] \"John Doe\"\n\n$student_id\n[1] 1234\n\n$grades\n[1] 95 82 91 97 93\n\n$final_grade\n[1] \"A\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(record)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\n3.  The same function to extract columns from data frames can also be used to list:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecord$student_id\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1234\n```\n\n\n:::\n\n```{.r .cell-code}\nrecord[[\"student_id\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1234\n```\n\n\n:::\n:::\n\n\n\n4.  You might also encounter [**lists without variable names**]{.underline}.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecord2 <- list(\"John Doe\", 1234)\nrecord2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"John Doe\"\n\n[[2]]\n[1] 1234\n```\n\n\n:::\n\n```{.r .cell-code}\nrecord2[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"John Doe\"\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\n### Matrix\n\n1.  **Matrices** are similar to data frames in that they are two-dimensional: they have rows and columns.\n\n2.  However, like numeric, character and logical vectors, entries in matrices have to be all the same type.\n\n3.  Yet **matrices have a major advantage over data frames**: we can perform matrix algebra operations, a powerful type of mathematical technique.\n\n4.  We can define a matrix using the `matrix` function. We need to specify the data in the matrix as well as **the number of rows and columns**.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mat <- matrix(data = 1:12, nrow = 4, ncol = 3) # 4 rows and 3 columns\n    mat\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2] [,3]\n    [1,]    1    5    9\n    [2,]    2    6   10\n    [3,]    3    7   11\n    [4,]    4    8   12\n    ```\n    \n    \n    :::\n    :::\n\n\n\n------------------------------------------------------------------------\n\n5.  You can access specific entries in a matrix using square brackets (`[`). If you want **the second row, third column**, you use:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mat[2, 3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 10\n    ```\n    \n    \n    :::\n    :::\n\n\n\n    If you want the entire second row, you leave the column spot empty:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mat[2, ]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  2  6 10\n    ```\n    \n    \n    :::\n    :::\n\n\n\n    Similarly, if you want the entire third column or 2 to 3 columns, you leave the row spot empty:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mat[, 3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  9 10 11 12\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    mat[, 2:3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2]\n    [1,]    5    9\n    [2,]    6   10\n    [3,]    7   11\n    [4,]    8   12\n    ```\n    \n    \n    :::\n    :::\n\n\n\n## Exercise 02-01\n\n1.  Make sure the US murders dataset is loaded. Use the function `str` to examine the structure of the murders object. Which of the following best describes the variables represented in this data frame?\n\n    -   The 51 states.\n    -   The murder rates for all 50 states and DC.\n    -   The state name, the abbreviation of the state name, the state’s region, and the state’s population and total number of murders for 2010.\n    -   `str` shows no relevant information.\n\n2.  What are the column names used by the data frame for these five variables?\n\n3.  Use the accessor `$` to extract the state abbreviations and assign them to the object `a`. What is the class of this object?\n\n4.  Now use the square brackets to extract the state abbreviations and assign them to the object `b`. Use the identical function to determine if a and b are the same.\n\n5.  We saw that the region column stores a factor. You can corroborate this by typing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(murders$region)\n```\n:::\n\n\n\nWith one line of code, use the functions levels and length to determine the number of regions defined by this dataset.\n\n6.  The function `table` takes a vector and returns the frequency of each element. You can quickly see how many states are in each region by applying this function. Use this function in one line of code to create a table of number of states per region.\n\n## Other features of R objects\n\n### Naming Convention\n\n-   When writing code in R, it’s important to choose variable names that are both **meaningful** and **avoid conflicts with existing functions** or reserved words in the language.\n\n-   Some basic rules in R are that variable names have to **start with a letter**, **can’t contain spaces**, and **should not be variables that are predefined** in R, such as `c`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ------------------\nthis.is.a.numer <- 3\nprint(this.is.a.numer)\n# ------------------\n2 <- this.is.a.numer\n`2` <- this.is.a.numer\nprint(2)\nprint(`2`)\n# ------------------\n`@_@` <- \"funny\"\npaste0(\"You look like \", `@_@`)\n# ------------------\n`@this` <- 3 \nprint(`@this`)\n# ------------------\n`I hate R programming` <- \"No, you don't\"\nprint(`I hate R programming`)\n```\n:::\n\n\n\n------------------------------------------------------------------------\n\n### Workspace\n\n-   We use `<-` to **assign** values to the variables. We can also assign values using `=` instead of `<-`, but we recommend against using `=` to avoid confusion.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    coef_a <- 1\n    coef_b <- 1\n    coef_c <- -1\n    ```\n    :::\n\n\n\n-   So we have object in the **global environment** of R session. The workspace **global environment** is the place storing the objects we can use\n\n-   You can see all the variables saved in your workspace by typing:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ls()\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n     [1] \"coef_a\"             \"coef_b\"             \"coef_c\"            \n     [4] \"EqualToSeven\"       \"LargerThanFive\"     \"mat\"               \n     [7] \"pop\"                \"record\"             \"record2\"           \n    [10] \"region\"             \"region_ordered\"     \"south_as_reference\"\n    [13] \"value\"              \"z\"                 \n    ```\n    \n    \n    :::\n    :::\n\n\n\n------------------------------------------------------------------------\n\n-   In RStudio, the *Environment* tab shows the values:\n\n    ![](https://rafalab.dfci.harvard.edu/dsbook-part-1/R/img/rstudio-environment.png)\n\n------------------------------------------------------------------------\n\n-   We should see `coef_a`, `coef_b`, and `coef_c`.\n\n-   **Missing R object in workspace**: If you try to recover the value of a variable that is not in your workspace, you receive an error. For example, if you type `some_random_object` you will receive the following message: `Error: object 'some_random_object' not found`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    print(some_random_object)\n    ```\n    \n    ::: {.cell-output .cell-output-error}\n    \n    ```\n    Error: object 'some_random_object' not found\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   Now since these values are saved in variables, to obtain a solution to our equation, we use the quadratic formula:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    (-coef_b + sqrt(coef_b^2 - 4*coef_a*coef_c))/(2*coef_a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 0.618034\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    (-coef_b - sqrt(coef_b^2 - 4*coef_a*coef_c))/(2*coef_a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] -1.618034\n    ```\n    \n    \n    :::\n    :::\n\n\n\n::: callout-note\n## Operators\n\n-   `-`: is a negative operator which switches the sign of object\n\n-   `+` and `*` and `/` : addition, multiplication, and division\n\n-   `sqrt`: a prebuilt R function of calculating the squared root of the object\n\n-   `^`: exponent operator to calculate the \"power\" of the \"base\"; `a^3` : a to the 3rd power\n:::\n\n------------------------------------------------------------------------\n\n-   **Help**: You can find out what the function expects and what it does by reviewing the very useful manuals included in R. You can get help by using the `help` function like this:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    help(\"log\")\n    ?log\n    ```\n    :::\n\n\n\n    -   The help page will show you what arguments the function is expecting. For example, `log` needs `x` and `base` to run.\n\n    -   The base of the function `log` defaults to `base = exp(1)` making `log` the natural log by default.\n\n        ![](images/clipboard-1863636552.png)\n\n    -   You can also use `args` to look at the arguments\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        args(log)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        function (x, base = exp(1)) \n        NULL\n        ```\n        \n        \n        :::\n        \n        ```{.r .cell-code}\n        log(x = 8, base = 2)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 3\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   If specifying [the arguments’ names]{.underline}, then we can include them in whatever order we want:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        log(base = 2, x = 8)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 3\n        ```\n        \n        \n        :::\n        :::\n\n\n\n------------------------------------------------------------------------\n\n### Prebuilt objects\n\n-   There are several datasets or values that are included for users to practice and test out functions. For example, you can use $\\pi$ in your calculation directly:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pi\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 3.141593\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   Or infinity value $\\infty$:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    Inf + 1\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] Inf\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   You can see all the available datasets by typing:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    data()\n    ```\n    :::\n\n\n\n-   For example, if you type `iris`, it will output the famous (Fisher's or Anderson's) iris data set gives the measurements in centimeters of the variables sepal length and width and petal length and width:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    iris\n    ?iris\n    ```\n    :::\n\n\n\n    You can check the detailed help page of `iris` using `?` as we did for functions.\n\n------------------------------------------------------------------------\n\n### Saving workspace\n\n-   Objects and functions remain in the workspace until you end your session or erase them with the function `rm`.\n\n-   **Autosave**: Your current workspaces also can be saved for later use.\n\n    -   In fact, when you quit R, Rstudio asks you if you want to save your workspace as `.RData`. If you do save it, the next time you start R, the program will restore the workspace.\n\n-   **ManualSave**: We actually recommend against saving the workspace this way because, as you start working on different projects, it will become harder to keep track of what is saved.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    save(file = \"project_lecture_2.RData\") # Save Workspace as project_lecture_2.RData\n    load(\"project_lecture_2.RData\") # Load Workspace\n    ```\n    :::\n\n\n\n## Commenting your code\n\n-   If a line of R code starts with the symbol `#`, it is a comment and is not evaluated.\n\n    -   We can use this to write reminders of why we wrote particular code:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ## Code to compute solution to quadratic equatio\n    ## Define the variables\n    coef_a <- 3 \n    coef_b <- 2\n    coef_c <- -\n    ## Now compute the solution\n    (-coef_b + sqrt(coef_b^2 - 4*coef_a*coef_c))/(2*coef_a)\n    (-coef_b - sqrt(coef_b^2 - 4*coef_a*coef_c))/(2*coef_a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] -0.8047379\n    ```\n    \n    \n    :::\n    :::\n\n\n\n# Vectors\n\n## Creating Vectors\n\n-   We can create vectors using the function c, which stands for concatenate. We use c to concatenate entries in the following way:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncodes <- c(380, 124, 818)\ncodes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 380 124 818\n```\n\n\n:::\n:::\n\n\n\n-   We can also create character vectors. We use the quotes to denote that the entries are characters rather than variable names.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountry <- c(\"italy\", \"canada\", \"egypt\")\n```\n:::\n\n\n\n-   In R you can also use single quotes:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountry <- c('italy', 'canada', 'egypt')\n```\n:::\n\n\n\nBut be careful not to confuse the single quote `'` with the back quote \\`.\n\n-   By now you should know that if you type:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountry <- c(italy, canada, egypt)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'italy' not found\n```\n\n\n:::\n:::\n\n\n\nyou receive an error because the variables italy, canada, and egypt are not defined. If we do not use the quotes, R looks for variables with those names and returns an error.\n\n## Named vectors\n\n-   Sometimes it is useful to name the entries of a vector. For example, when defining a vector of country codes, we can use the names to connect the two:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncodes <- c(italy = 380, canada = 124, egypt = 818)\ncodes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n italy canada  egypt \n   380    124    818 \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(codes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(codes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(codes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"italy\"  \"canada\" \"egypt\" \n```\n\n\n:::\n\n```{.r .cell-code}\nstr(codes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Named num [1:3] 380 124 818\n - attr(*, \"names\")= chr [1:3] \"italy\" \"canada\" \"egypt\"\n```\n\n\n:::\n:::\n\n\n\n## Sequences\n\n-   Another useful function for creating vectors generates sequences:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n\n::: callout-note\nThe first argument defines the start, and the second defines the end which is included.\n:::\n\n-   The default is to go up in increments of 1, but a third argument lets us tell it how much to jump by:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1, 10, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 5 7 9\n```\n\n\n:::\n:::\n\n\n\n-   If we want consecutive integers, we can use the following shorthand:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n\n## Subsetting\n\n-   We use square brackets to access specific elements of a vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncodes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n italy canada  egypt \n   380    124    818 \n```\n\n\n:::\n\n```{.r .cell-code}\ncodes[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncanada \n   124 \n```\n\n\n:::\n\n```{.r .cell-code}\ncodes[c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nitaly egypt \n  380   818 \n```\n\n\n:::\n\n```{.r .cell-code}\ncodes[1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n italy canada \n   380    124 \n```\n\n\n:::\n\n```{.r .cell-code}\ncodes[\"canada\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncanada \n   124 \n```\n\n\n:::\n\n```{.r .cell-code}\ncodes[c(\"egypt\",\"italy\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\negypt italy \n  818   380 \n```\n\n\n:::\n:::\n\n\n\n\n## Exercise 02-02\n\n1.  What is the sum of the first 100 positive integers? The formula for the sum of integers 1 through n is $n(n+1)/2$. Define\n\n    $n=100$ and then use R to compute the sum of 1 through 100 using the formula. What is the sum?\n\n2.  Now use the same formula to compute the sum of the integers from 1 through 1000.\n\n3.  Look at the result of typing the following code into R:\n\n    -   Based on the result, what do you think the functions `seq` and `sum` do? You can use help.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 1000 \nx <- seq(1, n) \nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 500500\n```\n\n\n:::\n:::\n\n\n\n4.  In math and programming, we say that we evaluate a function when we replace the argument with a given value. So if we type `sqrt(4)`, we evaluate the `sqrt` function. In R, you can evaluate a function inside another function. The evaluations happen from the inside out. Use one line of code to compute the log (use `log()` function), in base 10, of the square root of 100.\n\n## Coercion\n\n-    When an entry does not match the expected, some of the prebuilt R functions try to guess what was meant before throwing an error.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, \"canada\", 3)\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"      \"canada\" \"3\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n::: callout-note\nR *coerced* the data into characters. It guessed that because you put a character string in the vector, you meant the 1 and 3 to actually\nbe character strings `\"1\"` and `\"3\"`.\n:::\n\n------------------------------------------------------------------------\n\n-   R also offers functions to change from one type to another. For example, you can turn numbers into characters with:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:5\ny <- as.character(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(y)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in sum(y): invalid 'type' (character) of argument\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(as.numeric(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n:::\n\n\n\n## Not availables (NA)\n\n-   A special value called an `NA` for “not available”:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"1\", \"b\", \"3\")\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1 NA  3\n```\n\n\n:::\n:::\n\n\n\n-   You can also calculate the summary statistics of vector including `NA` using `sum` or `mean`\n\n    -   The solution is add `na.rm` argument to remove the `NA` from the vector\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(x)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in sum(x): invalid 'type' (character) of argument\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in sum(x, na.rm = TRUE): invalid 'type' (character) of argument\n```\n\n\n:::\n:::\n\n\n\n## Sorting\n\n-   We can sort the numeric vector from largest to lowest using `sort`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dslabs)\nsort(murders$total)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]    2    4    5    5    7    8   11   12   12   16   19   21   22   27   32\n[16]   36   38   53   63   65   67   84   93   93   97   97   99  111  116  118\n[31]  120  135  142  207  219  232  246  250  286  293  310  321  351  364  376\n[46]  413  457  517  669  805 1257\n```\n\n\n:::\n:::\n\n\n\n-   To identify the index that sorts input vectors, we can use `order`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nposition_of_rankings = order(murders$total) \nposition_of_rankings\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 46 35 30 51 12 42 20 13 27 40  2 16 45 49 28 38  8 24 17  6 32 29  4 48  7\n[26] 50  9 37 18 22 25  1 15 41 43  3 31 47 34 21 36 26 19 14 11 23 39 33 10 44\n[51]  5\n```\n\n\n:::\n\n```{.r .cell-code}\nmurders[position_of_rankings, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                  state abb        region population total\n46              Vermont  VT     Northeast     625741     2\n35         North Dakota  ND North Central     672591     4\n30        New Hampshire  NH     Northeast    1316470     5\n51              Wyoming  WY          West     563626     5\n12               Hawaii  HI          West    1360301     7\n42         South Dakota  SD North Central     814180     8\n20                Maine  ME     Northeast    1328361    11\n13                Idaho  ID          West    1567582    12\n27              Montana  MT          West     989415    12\n40         Rhode Island  RI     Northeast    1052567    16\n2                Alaska  AK          West     710231    19\n16                 Iowa  IA North Central    3046355    21\n45                 Utah  UT          West    2763885    22\n49        West Virginia  WV         South    1852994    27\n28             Nebraska  NE North Central    1826341    32\n38               Oregon  OR          West    3831074    36\n8              Delaware  DE         South     897934    38\n24            Minnesota  MN North Central    5303925    53\n17               Kansas  KS North Central    2853118    63\n6              Colorado  CO          West    5029196    65\n32           New Mexico  NM          West    2059179    67\n29               Nevada  NV          West    2700551    84\n4              Arkansas  AR         South    2915918    93\n48           Washington  WA          West    6724540    93\n7           Connecticut  CT     Northeast    3574097    97\n50            Wisconsin  WI North Central    5686986    97\n9  District of Columbia  DC         South     601723    99\n37             Oklahoma  OK         South    3751351   111\n18             Kentucky  KY         South    4339367   116\n22        Massachusetts  MA     Northeast    6547629   118\n25          Mississippi  MS         South    2967297   120\n1               Alabama  AL         South    4779736   135\n15              Indiana  IN North Central    6483802   142\n41       South Carolina  SC         South    4625364   207\n43            Tennessee  TN         South    6346105   219\n3               Arizona  AZ          West    6392017   232\n31           New Jersey  NJ     Northeast    8791894   246\n47             Virginia  VA         South    8001024   250\n34       North Carolina  NC         South    9535483   286\n21             Maryland  MD         South    5773552   293\n36                 Ohio  OH North Central   11536504   310\n26             Missouri  MO North Central    5988927   321\n19            Louisiana  LA         South    4533372   351\n14             Illinois  IL North Central   12830632   364\n11              Georgia  GA         South    9920000   376\n23             Michigan  MI North Central    9883640   413\n39         Pennsylvania  PA     Northeast   12702379   457\n33             New York  NY     Northeast   19378102   517\n10              Florida  FL         South   19687653   669\n44                Texas  TX         South   25145561   805\n5            California  CA          West   37253956  1257\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\n### Ranking\n\n-   The function `rank` is also related to order and can be useful:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(31, 4, 15, 92, 65)\nrank(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 1 2 5 4\n```\n\n\n:::\n:::\n\n\n\n-   `order` and `sort` are functions for sorting the data frame. `rank` is more easy to used for filter certain cases with specific ranking.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmurders[rank(murders$total) == 1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     state abb    region population total\n46 Vermont  VT Northeast     625741     2\n```\n\n\n:::\n\n```{.r .cell-code}\nmurders[rank(murders$total) == max(rank(murders$total)), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       state abb region population total\n5 California  CA   West   37253956  1257\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\n### Vector arithmeics\n\n-   You can summarize a numeric vector using some familiar math terms\n\n    -   You can use `min`, `max`, `mean`, `median`, and `sd` R functions to calculate summary statistics of a vector\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:5\nmean(x); median(x); min(x); max(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n-   You can get positions of largest number or lowest number or certain number\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(31, 4, 15, 92, 65)\n    which.max(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 4\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    which.min(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 2\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    which(x == 4)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 2\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n## Exercise 02-03\n\n1 We will use the US murders dataset for this exercises. Make sure you load it prior to starting. Use the `$` operator to access the population size data and store it as the object `pop`. Then use the sort function to redefine `pop` so that it is sorted. Finally, use the `[` operator to report the smallest population size.\n\n2 Now instead of the smallest population size, find the index of the entry with the smallest population size. Hint: use order instead of sort.\n\n3 We can actually perform the same operation as in the previous exercise using the function which.min. Write one line of code that does this.\n\n4 Now we know how small the smallest state is and we know which row represents it. Which state is it? Define a variable states to be the state names from the murders data frame. Report the name of the state with the smallest population.\n\n5. You can create a data frame using the data.frame function. Here is a quick example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- c(35, 88, 42, 84, 81, 30)\ncity <- c(\"Beijing\", \"Lagos\", \"Paris\", \"Rio de Janeiro\", \n          \"San Juan\", \"Toronto\")\ncity_temps <- data.frame(name = city, temperature = temp)\n```\n:::\n\n\n\nUse the `rank` function to determine the population rank of each state from smallest population size to biggest. Save these ranks in an object called ranks, then create a data frame with the state name and its rank. Call the data frame `my_df`.\n\n6. Repeat the previous exercise, but this time order my_df so that the states are ordered from least populous to most populous. Hint: create an object ind that stores the indexes needed to order the population values. Then use the bracket operator [ to re-order each column in the data frame.\n\n7. The na_example vector represents a series of counts. You can quickly examine the object using:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(na_example)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:1000] 2 1 3 2 1 3 1 4 3 2 ...\n```\n\n\n:::\n:::\n\n\n\nHowever, when we compute the average with the function mean, we obtain an NA:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(na_example)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\nThe `is.na` function returns a logical vector that tells us which entries are NA. Assign this logical vector to an object called ind and determine how many NAs does na_example have.\n\n8. Now compute the average again, but only for the entries that are not NA. Hint: remember the ! operator, which turns FALSE into TRUE and vice versa.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}