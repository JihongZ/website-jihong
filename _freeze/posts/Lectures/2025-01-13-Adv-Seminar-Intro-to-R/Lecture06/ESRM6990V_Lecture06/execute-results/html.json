{
  "hash": "c3af19809f3061c5976732c8596644a6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lecture 06: Date, Time, and Locales\"\nsubtitle: \"`dplyr` package\"\nauthor: \"Jihong Zhang*, Ph.D\"\ninstitute: | \n  Educational Statistics and Research Methods (ESRM) Program*\n  \n  University of Arkansas\ndate: \"2025-02-05\"\nsidebar: false\nexecute: \n  eval: true\n  echo: true\n  warning: false\noutput-location: default\ncode-annotations: below\nhighlight-style: \"nord\"\nformat: \n  html:\n    code-tools: true\n    code-line-numbers: false\n    code-fold: false\n    number-offset: 0\n  uark-revealjs:\n    scrollable: true\n    chalkboard: true\n    embed-resources: false\n    code-fold: false\n    number-sections: false\n    footer: \"ESRM 64503 - Lecture 03: Object/Function/Package\"\n    slide-number: c/t\n    tbl-colwidths: auto\n    output-file: slides-index.html\n---\n\n\n\n\n[Class Outline]{.redcolor .bigger}\n\n1.  Talk about the date-time variables\n2.  Locales related to timezone\n\n# Introduction to Date-Time Parsing\n\n\n\n## Importance of Date-Time Data\n\n-   Dates and times are critical for tracking temporal data in analysis.\n-   Proper handling ensures accurate filtering, summarization, and visualization.\n-   Base R provides the `Date` and `POSIXct` types to manage date-time information.\n    - `tidyverse` provides more types \n    \n::: callout-tip\nYou should always use the simplest possible data type that works for your needs. That means if you can use a date instead of a date-time, you should. Date-times are substantially more complicated because of the need to handle time zones, which we’ll come back to at the end of the chapter.\n:::\n\n## Using `lubridate` for Date-Time Parsing\n\n[Loading the Package]{.bluecolor .bigger}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n# or\nlibrary(lubridate)\n```\n:::\n\n\n\n\n## Create date/time variable\n\n- Three types of date/time data that refer to an instant in time:\n    - A date. Tibbles print this as <date>.\n    - A time within a day. Tibbles print this as <time>.\n    - A date-time is a date plus a time: it uniquely identifies an instant in time (typically to the nearest second). \n        - Tibbles prints this as <dttm>. Base R calls these POSIXct, but that doesn’t exactly trip off the tongue.\n\n- To get the current date or date-time you can use `today()` or `now()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-20\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-20 09:52:29 CST\"\n```\n\n\n:::\n:::\n\n\n\n\n## Import\n\n- If your CSV contains an ISO8601 `date` or `date-time`, you don’t need to do anything; `readr::read_csv()` will automatically recognize it:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsv <- \"\n  date, datetime\n  2022-01-02,2022-01-02 05:12\n\"\nread_csv(csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  date       datetime           \n  <date>     <dttm>             \n1 2022-01-02 2022-01-02 05:12:00\n```\n\n\n:::\n:::\n\n\n\n\n::: callout-tip\nThe date format follows ISO8601. If you haven’t heard of ISO8601 before, it’s an international standard for writing dates where the components of a date are organized from biggest to smallest separated by `-`. For example, in ISO8601 May 3 2022 is 2022-05-03.\n:::\n\n---\n\n### If you date variable does not follow ISO8601...\n\n- For other date-time formats, you’ll need to use `col_types=` plus `col_date()` or `col_datetime()` along with a date-time format.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsv <- \"\n  date\n  01/02/15\n\"\n\nread_csv(csv, col_types = cols(date = col_date(\"%m/%d/%y\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  date      \n  <date>    \n1 2015-01-02\n```\n\n\n:::\n\n```{.r .cell-code}\nread_csv(csv, col_types = cols(date = col_date(\"%d/%m/%y\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  date      \n  <date>    \n1 2015-02-01\n```\n\n\n:::\n\n```{.r .cell-code}\nread_csv(csv, col_types = cols(date = col_date(\"%y/%m/%d\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  date      \n  <date>    \n1 2001-02-15\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n### Date formats can be understood by readr\n\n| Type | Code | Meaning | Example |\n| --- | --- | --- | --- |\n| Year | `%Y` | 4 digit year | 2021 |\n|  | `%y` | 2 digit year | 21 |\n| Month | `%m` | Number | 2 |\n|  | `%b` | Abbreviated name | Feb |\n|  | `%B` | Full name | February |\n| Day | `%d` | One or two digits | 2 |\n|  | `%e` | Two digits | 02 |\n| Time | `%H` | 24-hour hour | 13 |\n|  | `%I` | 12-hour hour | 1 |\n|  | `%p` | AM/PM | pm |\n|  | `%M` | Minutes | 35 |\n|  | `%S` | Seconds | 45 |\n|  | `%OS` | Seconds with decimal component | 45.35 |\n|  | `%Z` | Time zone name | America/Chicago |\n|  | `%z` | Offset from UTC | +0800 |\n| Other | `%.` | Skip one non-digit | : |\n|  | `%*` | Skip any number of non-digits |  |\n\n\n## The `Date` Type in base R\n\n-   Dates are stored as the number of days since January 1, 1970 (epoch reference).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.Date(\"1970-01-01\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1970-01-01\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nformat(as.Date(\"1970-01-01\"), format = \"%Y/%m/%d\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1970/01/01\"\n```\n\n\n:::\n:::\n\n\n\n\n-   Convert character strings into `Date` format:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.Date(\"2025-02-13\")  # Convert string to Date type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-13\"\n```\n\n\n:::\n:::\n\n\n\n\n-   You can have access to the system date:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.Date()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-20\"\n```\n\n\n:::\n:::\n\n\n\n\n## Parsing Date From String\n\n-   `lubridate` provides functions to interpret and standardize date formats.\n  \n  - Parse dates with year, month, and day components\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## heterogeneous formats in a single vector:\nx <- c(\"2009-01-01\", \"09/01/02\", \"2009.Jan.2\", \"090102\")\nymd(x)  # Interprets different formats correctly\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2009-01-01\" \"2009-01-02\" \"2009-01-02\" \"2009-01-02\"\n```\n\n\n:::\n:::\n\n\n\n\n## Handling Different Date Orders\n\n-   Formats can be ambiguous, `lubridate` helps with appropriate parsing:\n\n    - Once parsed, the object type will be converted to `Date` \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"09/01/02\"\nymd(x)  # Assumes year-month-day\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2009-01-02\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmdy(x)  # Assumes month-day-year\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2002-09-01\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndmy(x)  # Assumes day-month-year\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2002-01-09\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(dmy(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n\n\n\n- In `lubridate`, there are various type of parsing functions that can parse the character based on the sequence of your date string\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd_hms(\"2024-07-13 14:45:00\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-07-13 14:45:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nymd_hm(\"2024-07-13 14:45\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-07-13 14:45:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmdy_hm(\"07-13-2024 14:45\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-07-13 14:45:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmdy_hm(\"07.13.2024 14:45\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-07-13 14:45:00 UTC\"\n```\n\n\n:::\n:::\n\n\n\n\n## Example: Multiple columns of date components\n\n- Instead of a single string, sometimes you’ll have the individual components of the date-time spread across multiple columns.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights13)\nflights_datetime <- flights |> \n  select(year, month, day, hour, minute)\nflights_datetime\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 5\n    year month   day  hour minute\n   <int> <int> <int> <dbl>  <dbl>\n 1  2013     1     1     5     15\n 2  2013     1     1     5     29\n 3  2013     1     1     5     40\n 4  2013     1     1     5     45\n 5  2013     1     1     6      0\n 6  2013     1     1     5     58\n 7  2013     1     1     6      0\n 8  2013     1     1     6      0\n 9  2013     1     1     6      0\n10  2013     1     1     6      0\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n- To create a date/time from this sort of input, use `make_date()` for dates, or `make_datetime()` for date-times:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_datetime |> \n  mutate(departure_time = make_datetime(year, month, day, hour, minute))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 6\n    year month   day  hour minute departure_time     \n   <int> <int> <int> <dbl>  <dbl> <dttm>             \n 1  2013     1     1     5     15 2013-01-01 05:15:00\n 2  2013     1     1     5     29 2013-01-01 05:29:00\n 3  2013     1     1     5     40 2013-01-01 05:40:00\n 4  2013     1     1     5     45 2013-01-01 05:45:00\n 5  2013     1     1     6      0 2013-01-01 06:00:00\n 6  2013     1     1     5     58 2013-01-01 05:58:00\n 7  2013     1     1     6      0 2013-01-01 06:00:00\n 8  2013     1     1     6      0 2013-01-01 06:00:00\n 9  2013     1     1     6      0 2013-01-01 06:00:00\n10  2013     1     1     6      0 2013-01-01 06:00:00\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n### Calculate departure time and arrival time\n\n- In `flights`, `dep_time` and `arr_time` represents the time with the format `HHMM` or `HMM`. \n  - The first two digits contains hours; The second two digits contains minuts\n  - `dep_time %/% 100` will be hours \n  - `dep_time %% 100` will be minutes \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  select(dep_time) |> \n  mutate(\n    hours = dep_time %/% 100,\n    minutes = dep_time %% 100,\n  ) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 3\n   dep_time hours minutes\n      <int> <dbl>   <dbl>\n 1      517     5      17\n 2      533     5      33\n 3      542     5      42\n 4      544     5      44\n 5      554     5      54\n 6      554     5      54\n 7      555     5      55\n 8      557     5      57\n 9      557     5      57\n10      558     5      58\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n### Create departure time\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## create a self-made function that can read in HMM time format\nmake_datetime_100 <- function(year, month, day, time) {\n  make_datetime(year, month, day, time %/% 100, time %% 100)\n}\n\nflights_dt <- flights |> \n  filter(!is.na(dep_time), !is.na(arr_time)) |> # remove missing date\n  mutate(\n    dep_time = make_datetime_100(year, month, day, dep_time),\n    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),\n  ) |> \n  select(origin, dest, dep_time, sched_dep_time)\n\nflights_dt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 328,063 × 4\n   origin dest  dep_time            sched_dep_time     \n   <chr>  <chr> <dttm>              <dttm>             \n 1 EWR    IAH   2013-01-01 05:17:00 2013-01-01 05:15:00\n 2 LGA    IAH   2013-01-01 05:33:00 2013-01-01 05:29:00\n 3 JFK    MIA   2013-01-01 05:42:00 2013-01-01 05:40:00\n 4 JFK    BQN   2013-01-01 05:44:00 2013-01-01 05:45:00\n 5 LGA    ATL   2013-01-01 05:54:00 2013-01-01 06:00:00\n 6 EWR    ORD   2013-01-01 05:54:00 2013-01-01 05:58:00\n 7 EWR    FLL   2013-01-01 05:55:00 2013-01-01 06:00:00\n 8 LGA    IAD   2013-01-01 05:57:00 2013-01-01 06:00:00\n 9 JFK    MCO   2013-01-01 05:57:00 2013-01-01 06:00:00\n10 LGA    ORD   2013-01-01 05:58:00 2013-01-01 06:00:00\n# ℹ 328,053 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n---\n\n### Visualize distribution of departure time\n\n- With this data, we can visualize the distribution of departure times on January 02, 2013\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_dt |> \n  filter(dep_time < ymd_hms(\"2013-01-01 23:00:00\")) |> \n  ggplot() + \n  geom_histogram(aes(x = dep_time), fill = \"red\", binwidth = 1800, alpha = .8) + # 1800 seconds = 30 min\n  scale_x_datetime(date_breaks = \"1 hour\") +\n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture06_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n\n## Get date/times as numeric offsets\n\n- Sometimes you’ll get date/times as numeric offsets from the “Unix Epoch”, **1970-01-01**. If the offset is in seconds, use as_datetime(); if it’s in days, use as_date().\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_datetime(60 * 60 * 10) # offset in seconds\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1970-01-01 10:00:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas_date(365 * 10 + 2) # offset in days\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1980-01-01\"\n```\n\n\n:::\n:::\n\n\n\n\n## Extracting Date Components\n\n-   Once parsed, individual components like year, month, or day information can be extracted for further analysis:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndates <- as.Date(c(\"2016-05-31 12:34:56\", \n                   \"2016-08-08 12:34:56\", \n                   \"2016-09-19 12:34:56\"))\n\nyear(dates)  # Extract year\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2016 2016 2016\n```\n\n\n:::\n\n```{.r .cell-code}\nmonth(dates)  # Extract month\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 8 9\n```\n\n\n:::\n\n```{.r .cell-code}\nday(dates)  # Extract day\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31  8 19\n```\n\n\n:::\n\n```{.r .cell-code}\nyday(dates) # day of the year\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 152 221 263\n```\n\n\n:::\n\n```{.r .cell-code}\nmday(dates) # day of the month\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31  8 19\n```\n\n\n:::\n\n```{.r .cell-code}\nwday(dates) # day of the week\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 2 2\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n- For `month()` and `wday()` you can set label = TRUE to return the abbreviated name of the month or day of the week\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonth(dates, label = TRUE) # day of the month\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] May Aug Sep\n12 Levels: Jan < Feb < Mar < Apr < May < Jun < Jul < Aug < Sep < ... < Dec\n```\n\n\n:::\n\n```{.r .cell-code}\nwday(dates, label = TRUE) # day of the week\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Tue Mon Mon\nLevels: Sun < Mon < Tue < Wed < Thu < Fri < Sat\n```\n\n\n:::\n:::\n\n\n\n\n\n## Rounding the Date\n\n-  `floor_date()`, `round_date()`, and `ceiling_date()` are useful to adjusting our dates. Each function takes a vector of dates to adjust and then the name of the unit to round down (floor), round up (ceiling), or round to. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndates <- as.Date(c(\"2016-05-31 12:34:56\", \n                   \"2016-08-08 12:34:56\", \n                   \"2016-09-19 12:34:56\"))\nfloor_date(dates, unit = \"week\") # Monday of the week\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2016-05-29\" \"2016-08-07\" \"2016-09-18\"\n```\n\n\n:::\n\n```{.r .cell-code}\nwday(dates)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 2 2\n```\n\n\n:::\n\n```{.r .cell-code}\nceiling_date(dates, unit = \"week\") # Sunday of the week\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2016-06-05\" \"2016-08-14\" \"2016-09-25\"\n```\n\n\n:::\n:::\n\n\n\n\n## Example: distribution of number of flights by week days\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2\"}\nflights_dt |> \n  mutate(wday = wday(dep_time, label = TRUE)) |> \n  ggplot(aes(x = wday, fill = wday)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture06_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\n\n---\n\n### Distribution of number of flights by week\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_dt |> \n  count(week = floor_date(dep_time, \"week\")) |> \n  ggplot(aes(x = week, y = n)) +\n  geom_line() + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture06_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Handling Date-Time with `POSIXct`\n\n-   Previous `Date` type variables contain year-month-day information\n-   The `POSIXct` class stores timestamps as seconds since epoch.\n-   Use `ymd_hms()` to parse full date-time values:\n    - Parse date-times with year, month, and day, hour, minute, and second components.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatetime_str <- \"2025-02-12 14:30:00\"\ndatetime <- ymd_hms(datetime_str)\nprint(datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-12 14:30:00 UTC\"\n```\n\n\n:::\n:::\n\n\n\n\n## Working with Time Zones\n\n-   Time zones are crucial when working with global data.\n-   `with_tz()` converts a time to a different zone without altering the actual time:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnow()  # Current system time\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-20 09:52:31 CST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nwith_tz(now(), \"America/New_York\")  # Convert to Eastern Time\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-20 10:52:31 EST\"\n```\n\n\n:::\n:::\n\n\n\n\n\n# Locales\n\n## Understanding Locales in R\n\n[What are Locales?]{.redcolor .bigger}\n\n-   Locales define how dates, times, numbers, and character encodings are interpreted.\n-   Key aspects include:\n    -   Date and time formats\n    -   Time zones\n    -   Character encoding\n    -   Decimal and grouping symbols\n\n## Checking and Setting Locales\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.getlocale()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\"\n```\n\n\n:::\n\n```{.r .cell-code}\nSys.setlocale(\"LC_ALL\", \"en_US.UTF-8\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\"\n```\n\n\n:::\n:::\n\n\n\n\n-   `LC_TIME`: Controls date-time formatting.\n-   `LC_NUMERIC`: Determines the decimal and grouping symbols.\n\n## Handling Different Locales\n\n-   Using `readr::locale()`\n-   The `readr` package allows setting locales while reading data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlocale()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<locale>\nNumbers:  123,456.78\nFormats:  %AD / %AT\nTimezone: UTC\nEncoding: UTF-8\n<date_names>\nDays:   Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), Thursday\n        (Thu), Friday (Fri), Saturday (Sat)\nMonths: January (Jan), February (Feb), March (Mar), April (Apr), May (May),\n        June (Jun), July (Jul), August (Aug), September (Sep), October\n        (Oct), November (Nov), December (Dec)\nAM/PM:  AM/PM\n```\n\n\n:::\n:::\n\n\n\n\n-   Specifying a locale allows you to parse dates in other languages:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparse_date(\"1 janvier 2015\", \"%d %B %Y\", locale = locale(\"fr\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2015-01-01\"\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_date(\"14 oct. 1979\", \"%d %b %Y\", locale = locale(\"fr\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1979-10-14\"\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_date(\"1994年10月01日\", \"%Y年%m月%d日\", locale = locale(\"zh\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1994-10-01\"\n```\n\n\n:::\n:::\n\n\n\n\nSee `vignette(\"locales\")` for more details\n\n## Timezones\n\nYou can see a complete list of time zones with `OlsonNames()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.timezone(location = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"America/Chicago\"\n```\n\n\n:::\n\n```{.r .cell-code}\nOlsonNames()[str_detect(OlsonNames(), \"America/N\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"America/Nassau\"                 \"America/New_York\"              \n[3] \"America/Nipigon\"                \"America/Nome\"                  \n[5] \"America/Noronha\"                \"America/North_Dakota/Beulah\"   \n[7] \"America/North_Dakota/Center\"    \"America/North_Dakota/New_Salem\"\n[9] \"America/Nuuk\"                  \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nparse_datetime(\"2001-10-10 20:10\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2001-10-10 20:10:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_datetime(\"2001-10-10 20:10\", locale = locale(tz = \"Pacific/Auckland\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2001-10-10 20:10:00 NZDT\"\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_datetime(\"2001-10-10 20:10\", locale = locale(tz = \"Europe/Dublin\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2001-10-10 20:10:00 IST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_datetime(\"2001-10-10 20:10\", locale = locale(tz = \"Asia/Hong_Kong\" ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2001-10-10 20:10:00 HKT\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncurrent_time <- Sys.Date()\ncurrent_time\ndifftime(\n  parse_datetime(current_time, locale = locale(tz = \"US/Central\")),\n  parse_datetime(current_time, locale = locale(tz = \"Asia/Hong_Kong\"))\n)\n```\n:::\n\n\n\n\n-   Note that “EST” is a Canadian time zone that does not have DST. It’s not Eastern Standard Time! Instead use:\n\n    -   PST/PDT = “US/Pacific”\n    -   CST/CDT = “US/Central”\n    -   MST/MDT = “US/Mountain”\n    -   EST/EDT = “US/Eastern”\n\n## Summary\n\n-   `lubridate` simplifies parsing and manipulating date-time data.\n-   Converting text-based dates into structured `Date` and `POSIXct` formats enables powerful analysis.\n-   Handling time zones correctly ensures accurate comparisons across regions.\n",
    "supporting": [
      "ESRM6990V_Lecture06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}