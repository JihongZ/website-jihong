{
  "hash": "76df52c3fd3226299b64b9b7aa6f5e52",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lecture 08: Data Visualization - Layers\"\nsubtitle: \"`ggplot2` package\"\nauthor: \"Jihong Zhang*, Ph.D\"\ninstitute: | \n  Educational Statistics and Research Methods (ESRM) Program*\n  \n  University of Arkansas\ndate: \"2025-02-05\"\nsidebar: false\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  message: false\noutput-location: default\ncode-annotations: below\nformat: \n  html:\n    code-tools: true\n    code-line-numbers: false\n    code-fold: false\n    number-offset: 0\n    fig.width: 10\n---\n\n\n\n------------------------------------------------------------------------\n\n::: objectives\n## Overview {.unnumbered}\n\n-   Questions:\n    -   \"How to build a graph in R?\"\n    -   \"What types of visualization are suitable for different types of data?\"\n-   Objectives:\n    -   \"Recognize the necessary elements to build a plot using the `ggplot2` package.\"\n    -   \"Define data, aesthetics and geometries for a basic graph.\"\n    -   \"Distinguish when to use or not to use `aes()` to change graph's aesthetics (e.g. colours, shapes).\"\n    -   \"Overlay multiple geometries on the same graph and define aesthetics separately for each.\"\n    -   \"Adjust and customize scales and labels in the graph.\"\n    -   \"Use `ggplot2` to produce several kinds of visualizations (for continuous and/or discrete data).\"\n    -   \"Distinguish which types of visualization are adequate for different types of data and questions.\"\n    -   \"Discuss the importance of scales when analysing and/or visualizing data\"\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-1-1.png){width=1152}\n:::\n:::\n\n\n\n## Background: Data\n\n-   We will use the data from the [Gapminder Foundation](https://www.gapminder.org/), which gives access to global data as well as many tools to help explore it.\n\n-   In these lessons we’re going to use some of these data to explore some of these data ourselves.\n\n-   We have two files with data relating to socio-economic statistics: world data for 2010 only and the same data for 1960 to 2010 (see the setup page for instructions on how to download the data). In this lesson we will use the 2010 data only, and then use the full dataset in future episodes.\n\n## List of columns\n\n| Column | Description |\n|--------------------------------|:---------------------------------------|\n| country | country name |\n| world_region | 6 world regions |\n| year | year that each datapoint refers to |\n| children_per_woman | total fertility rate |\n| life_expectancy | average number of years a newborn child would live if current mortality patterns were to stay the same |\n| income_per_person | gross domestic product per person adjusted for differences in purchasing power |\n| is_oecd | Whether a country belongs to the “OECD” (TRUE) or not (FALSE) |\n| income_groups | categorical classification of income groups |\n| population | total number of a country’s population |\n| main_religion | religion of the majority of population in 2008 |\n| child_mortality | death of children under 5 years old per 1000 births |\n| life_expectancy_female | life expectancy at birth, females |\n| life_expectancy_male | life expectancy at birth, males |\n\n## Read in Data\n\nAs usual when starting an analysis on a new script, let's start by loading the packages and reading the data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# Read the data, specifying how missing values are encoded\ngapminder2010 <- read_csv(here::here(root_path, \"gapminder2010_socioeconomic.csv\"), na = \"\")\n\nglimpse(gapminder2010)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 193\nColumns: 13\n$ country                <chr> \"Afghanistan\", \"Angola\", \"Albania\", \"Andorra\", …\n$ world_region           <chr> \"south_asia\", \"sub_saharan_africa\", \"europe_cen…\n$ year                   <dbl> 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010,…\n$ children_per_woman     <dbl> 5.82, 6.16, 1.65, NA, 1.87, 2.37, 1.55, 2.13, 1…\n$ life_expectancy        <dbl> 59.85, 59.94, 77.64, 82.29, 72.88, 75.82, 74.05…\n$ income_per_person      <dbl> 1672, 6360, 9928, 38982, 55363, 18912, 6703, 20…\n$ is_oecd                <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE…\n$ income_groups          <chr> \"low_income\", \"lower_middle_income\", \"upper_mid…\n$ population             <dbl> 29185511, 23356247, 2948029, NA, 8549998, 40895…\n$ main_religion          <chr> \"muslim\", \"christian\", \"muslim\", \"christian\", \"…\n$ child_mortality        <dbl> 87.95, 120.49, 13.30, 4.18, 8.48, 14.44, 18.52,…\n$ life_expectancy_female <chr> \"62.459\", \"58.033\", \"79.302\", \"-\", \"77.77\", \"78…\n$ life_expectancy_male   <dbl> 59.683, 52.848, 74.145, -999.000, 75.624, 71.83…\n```\n\n\n:::\n:::\n\n\n\n::: callout-important\nDO NOTE COPY-AND-PASTE `read_csv()` function. If you saved the data file in the same directory with you R code, use the following code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder2010 <- read_csv(\"gapminder2010_socioeconomic.csv\", na = \"\")\n```\n:::\n\n\n:::\n\n## Install and Load `ggplot2` package\n\n-   `ggplot2` package is included in `tidyverse`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n# or\nlibrary(ggplot2)\n```\n:::\n\n\n\n## Building a `ggplot2` graph\n\nTo build a `ggplot2` graph you need 3 basic pieces of information:\n\n1.  A **data.frame** with data to be plotted\n2.  The variables (columns of `data.frame`) that will be *mapped* to different **aesthetics** of the graph (e.g. axis, colours, shapes, etc.)\n3.  the **geometry** that will be drawn on the graph (e.g. points, lines, boxplots, violinplots, etc.)\n\nThis translates into the following basic syntax:\n\n``` r\nggplot(data = <data.frame>, \n       mapping = aes(x = <column of data.frame>, \n                     y = <column of data.frame>)) +\ngeom_<type of geometry>()\n```\n\n## First Visualization\n\n-   The question[^1] we're interested in is:\n    -   how much separation is there between different world regions in terms of family size and life expectancy?\n\n[^1]: For our first visualization, let's try to recreate one of the visualizations from [Hans Rosling's talk](https://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen?utm_campaign=tedspread&utm_medium=referral&utm_source=tedcomshare).\n\n<!-- -->\n\n-   We will explore this by using a [scatterplot](https://www.data-to-viz.com/graph/scatter.html) showing the relationship between `children_per_woman` and `life_expectancy`.\n\n-   Let's do it step-by-step to see how `ggplot2` works.\n\n(1). Start by giving data to `ggplot`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010) # <1>\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n1.  We replace `<data.frame>` with the object name of the target data frame\n\nThat \"worked\" (as in, we didn't get an error). But because we didn't give `ggplot()` any variables to be *mapped* to *aesthetic* components of the graph, we just got an empty square.\n\n(2) For **mappping columns to aesthetics**, we use the `aes()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010, \n       mapping = aes(x = children_per_woman, # <2>\n                     y = life_expectancy)) \n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n2.  We replaced `<column of the data.frame>` with the unquoted column name\n\nThat's better, now we have some axis. Notice how `ggplot()` defines the axis based on the range of data given. But it's still not a very interesting graph, because we didn't tell what it is we want to draw on the graph.\n\nThis is done by adding (literally `+`) **geometries** to our graph:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010, \n       mapping = aes(x = children_per_woman, \n                     y = life_expectancy)) + #<3>\n  geom_point() # <4>\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n3.  `+` add up a new layer onto the old layers\n4.  We replace `geom_<type of geometry>()` with `geom_point()`\n\n::: callout-important\nNotice how `geom_point()` warns you that it had to remove some missing values (if the data is missing for at least one of the variables, then it cannot plot the points).\n:::\n\n:::: discussion\n## Exercise {.unnumbered}\n\n[Aim]{.redcolor}: It would be useful to explore the pattern of missing data in these two variables. The `naniar` package provides a ggplot geometry that allows us to do this, by replacing `NA` values with values 10% lower than the minimum in the variable.\n\nTry and modify the previous graph, using the `geom_miss_point()` from this package. (hint: don't forget to load the package first using `library(naniar)`)\n\n[Questions]{.redcolor}: What can you conclude from this exploration? Are the data missing at random?\n\n::: {.callout-note collapse=\"true\"}\n## Answer\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(naniar) # load the naniar package; this should be placed on top of the script\nggplot(data = gapminder2010, \n       mapping = aes(x = children_per_woman, y = life_expectancy)) +\n  geom_miss_point()\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n-   The data do not seem to be missing at random:\n    1.  it seems to be the case that when data is missing for one variable it is often also missing for the other.\n    2.  And there seem to be more missing data for `children_per_woman` than `life_expectancy`.\n    3.  However, we only have 9 cases with missing data, so perhaps we should not make very strong conclusions from this. But it gives us more questions that we could follow up on: are the countries with missing data generaly lacking other statistics? Is it harder to obtain data for fertility than for life expectancy?\n:::\n::::\n\n## Changing how geometries look like\n\nWe can change how geometries look like in several ways, for example their transparency, color, size, shape, etc.\n\nTo know which *aesthetic* components can be changed in a particular geometry, look at its documentation (e.g. `?geom_point`) and look under the \"Aesthetics\" section of the help page.\n\n-   For example,\n\n::: {.callout-note collapse=\"true\"}\n## the documentation for `?geom_point` says:\n\n-   geom_point() understands the following aesthetics (required aesthetics are in bold):\n    -   **x**\n    -   **y**\n    -   alpha\n    -   colour\n    -   fill\n    -   group\n    -   shape\n    -   size\n    -   stroke\n:::\n\nFor example, we can change the transparency of the points in our scatterplot using `alpha` argument in `geom_point()` (`alpha` varies between 0-1 with zero being transparent and 1 being opaque):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010, \n       mapping = aes(x = children_per_woman, \n                     y = life_expectancy)) +\n  geom_point(alpha = 0.5) # <4>\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n4.  Arguments in `geom_point()` adjusts the characteristics of **points**\n\nAdding transparency to points is useful when data is very packed, as you can then see which areas of the graph are more densely occupied with points.\n\n:::: discussion\n## Exercise {.unnumbered}\n\n[Aim]{.redcolor}: Try changing the *size*, *shape* and *colour* of the points (hint: web search \"ggplot2 point shapes\" to see how to make a triangle)\n\nYou can find out R colors' name using `colors()` functions. Below is the index for point shapes.\n\n![](images/clipboard-2299570783.png){width=\"200\"}\n\n::: {.callout-note collapse=\"true\"}\n## Solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010, \n       mapping = aes(x = children_per_woman, y = life_expectancy)) +\n  geom_point(size = 3, shape = 6, colour = \"brown\")\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n:::\n::::\n\n## Changing aesthetics based on data\n\nIn the above exercise we changed the color of the points by defining it ourselves. However, it would be better if we colored the points based on a variable of interest.\n\nFor example, to explore our question of how different world regions really are, we want to colour the countries in our graph accordingly.\n\nWe can do this by passing this information to the `color` aesthetic *inside* the `aes()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010, \n       mapping = aes(x = children_per_woman, \n                     y = life_expectancy, \n                     color = world_region)) + #<5>\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n5.  We changed the points' color based on their world regions.\n\nFor example, if we look at the points with red color, when `world_region == america`, `geom_point()` function maps the point's color as [red]{style=\"color: red\"} and x-axis as value of `children_per_woman` and y-axis as the value of `life_expectancy` :\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n| children_per_woman| life_expectancy|world_region |color |\n|------------------:|---------------:|:------------|:-----|\n|               2.37|           75.82|america      |red   |\n|               2.13|           76.61|america      |red   |\n|               1.87|           73.42|america      |red   |\n|               2.72|           73.59|america      |red   |\n|               3.20|           70.78|america      |red   |\n|               1.81|           74.38|america      |red   |\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(sliced_points) + \n  geom_point(aes(x = children_per_woman, \n                 y = life_expectancy, \n                 color = world_region))\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-note\n## Aesthetics: inside or outside `aes()`?\n\n-   The previous examples illustrate an important distinction between *aesthetics* defined inside or outside of `aes()`:\n\n    -   if you want the *aesthetic* to change **based on the data** it goes **inside `aes()`**\n    -   if you want to **manually specify** how the geometry should look like, it goes **outside `aes()`**\n:::\n\n:::: discussion\n## Exercise {.unnumbered}\n\nMake a [boxplot](https://www.data-to-viz.com/caveat/boxplot.html) that shows the distribution of `children_per_woman` (y-axis) for each `world_region` (x-axis). (Hint: `geom_boxplot()`)\n\n**Bonus:** Colour the *inside* of the boxplots by `income_groups`.\n\n::: {.callout-note collapse=\"true\"}\n## Solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010,\n       aes(x = world_region, y = children_per_woman)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n-   To colour the inside of the boxplot we use the *fill* geometry. `ggplot2` will automatically split the data into groups and make a boxplot for each.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010,\n       aes(x = world_region, y = children_per_woman, fill = income_groups)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n-   Some groups have too few observations (possibly only 1) and so we get odd boxplots with only a line representing the median, because there isn't enough variation in the data to have distinct quartiles.\n\n-   Also, the labels on the x-axis are all overlapping each other. We will see how to solve this later.\n:::\n::::\n\n### Multiple geometries\n\nOften, we may want to overlay several geometries on top of each other. For example, add a [violin plot](https://www.data-to-viz.com/graph/violin.html) together with a boxplot so that we get both representations of the data in a single graph.\n\nLet's start by making a violin plot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# scale the violins by \"width\" rather than \"area\", which is the default\nggplot(gapminder2010, aes(x = world_region, y = children_per_woman)) +\n  geom_violin(scale = \"width\")\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\nTo layer a boxplot on top of it we \"add\" (with `+`) another geometry to the graph:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make boxplots thinner so the shape of the violins is visible\nggplot(gapminder2010, aes(x = world_region, y = children_per_woman)) +\n  geom_violin(scale = \"width\") +\n  geom_boxplot(width = 0.2)\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nThe order in which you add the geometries defines the order they are \"drawn\" on the graph. For example, try swapping their order and see what happens.\n\nNotice how we've shortened our code by omitting the names of the options `data =` and `mapping =` inside `ggplot()`. Because the data is always the first thing given to `ggplot()` and the mapping is always identified by the function `aes()`, this is often written in the more compact form as we just did.\n\n### Controlling aesthetics in individual geometries\n\nLet's say that, in the graph above, we wanted to colour the violins by world region, but keep the boxplots without colour.\n\nAs we've learned, because we want to colour our geometries *based on data*, this goes inside the `aes()` part of the graph:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use the `fill` aesthetic, which colours the **inside** of the geometry\nggplot(gapminder2010, aes(x = world_region, y = children_per_woman, fill = world_region)) +\n  geom_violin(scale = \"width\") +\n  geom_boxplot(width = 0.2)\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\nOK, this is not what we wanted. Both *geometries* (boxplots and violins) got coloured.\n\nIt turns out that we can control aesthetics individually in each geometry, by puting the `aes()` inside the geometry function itself. Like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder2010, aes(x = world_region, y = children_per_woman)) +\n  geom_violin(aes(fill = world_region), scale = \"width\") +\n  geom_boxplot(width = 0.2)\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n:::: discussion\n## Exercise {.unnumbered}\n\n-   Modify the graph above by colouring the inside of the boxplots by world region and the inside of the violins in grey colour.\n\n-   Although we decided to colour our violin plots, is this colouring necessary?\n\n::: {.callout-note collapse=\"true\"}\n## Solution\n\nBecause we want to define the fill colour of the violin \"manually\" it goes *outside* `aes()`. Whereas for the violin we want the fill to depend on a column of data, so it goes inside `aes()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder2010, aes(x = world_region, y = children_per_woman)) +\n  geom_violin(fill = \"grey\", scale = \"width\") +\n  geom_boxplot(aes(fill = world_region), width = 0.2)\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\nAlthough this graph looks appealing, the colour is redundant with the x-axis labels. So, the same information is being shown with multiple *aesthetics*. This is not necessarily incorrect, but we should generally [avoid too much gratuitous use of colour in graphs](https://serialmentor.com/dataviz/color-pitfalls.html). At the very least we should remove the legend from this graph.\n:::\n::::\n\n## Facets\n\nYou can split your plot into multiple panels by using *facetting*. There are two types of *facet* functions:\n\n-   `facet_wrap()` arranges a one-dimensional sequence of panels to fit on one page.\n-   `facet_grid()` allows you to form a matrix of rows and columns of panels.\n\nBoth geometries allow to to specify faceting variables specified with `vars()`. In general:\n\n-   `facet_wrap(facets = vars(facet_variable))`\n-   `facet_grid(rows = vars(row_variable), cols = vars(col_variable))`.\n\nFor example, if we want to visualise the scatterplot above split by `income_groups`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder2010, \n       aes(x = children_per_woman, y = life_expectancy, colour = world_region)) +\n  geom_point() +\n  facet_wrap(facets = vars(income_groups))\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\nIf instead we want a *matrix* of facets to display `income_groups` and `economic_organisation`, then we use `facet_grid()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder2010, \n       aes(x = children_per_woman, y = life_expectancy, colour = world_region)) +\n  geom_point() +\n  facet_grid(rows = vars(income_groups), cols = vars(is_oecd))\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\nFinally, with `facet_grid()`, you can organise the panels just by rows or just by columns. Try running this code yourself:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# One column, facet by rows\nggplot(gapminder2010, \n       aes(x = children_per_woman, y = life_expectancy, colour = world_region)) +\n  geom_point() +\n  facet_grid(rows = vars(is_oecd))\n\n# One row, facet by column\nggplot(gapminder2010, \n       aes(x = children_per_woman, y = life_expectancy, colour = world_region)) +\n  geom_point() +\n  facet_grid(cols = vars(is_oecd))\n```\n:::\n\n\n\n## Modifying scales\n\nOften you want to change how the scales of your plot are defined. In `ggplot2` scales can refer to the *x* and *y* aesthetics, but also to other aesthetics such as *colour*, *shape*, *fill*, etc.\n\nWe modify scales using the *scale* family of functions. These functions always follow the following naming convention: `scale_<aesthetic>_<type>`, where:\n\n-   `<aesthetic>` refers to the aesthetic for that scale function (e.g. `x`, `y`, `colour`, `fill`, `shape`, etc.)\n-   `<type>` refers to the type of aesthetic (e.g. `discrete`, `continuous`, `manual`)\n\nLet's see some examples.\n\n### Change a numerical axis scale\n\nTaking the graph from the previous exercise we can modify the x and y axis scales, for example to emphasise a particular range of the data and define the breaks of the axis ticks.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Emphasise countries with 1-3 children and > 70 years life expectancy\nggplot(gapminder2010, \n       aes(x = children_per_woman, y = life_expectancy)) +\n  geom_point() +\n  scale_x_continuous(limits = c(1, 3), breaks = seq(0, 3, by = 1)) +\n  scale_y_continuous(limits = c(70, 85))\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\nYou can also apply transformations to the data. For example, consider the distribution of income across countries, represented using a [histogram](https://www.data-to-viz.com/graph/histogram.html):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder2010, aes(x = income_per_person)) +\n  geom_histogram()\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\nWe can see that this distribution is [highly skewed](https://en.wikipedia.org/wiki/Skewness), with some countries having very large values, while others having very low values. One common data transformation to solve this issue is to log-transform our values. We can do this within the scale function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder2010, aes(x = income_per_person)) +\n  geom_histogram() +\n  scale_x_continuous(trans = \"log10\")\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n\nNotice how the interval between the x-axis values is not constant anymore, we go from \\$1000 to \\$10,000 and then to \\$100,000. That's because our data is now plotted on a log-scale.\n\nYou could transform the data directly in the variable given to x:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder2010, aes(x = log10(income_per_person))) +\n  geom_histogram()\n```\n:::\n\n\n\nThis is also fine, but in this case the x-axis scale would show you the log-transformed values, rather than the original values. (Try running the code yourself to see the difference!)\n\n### Change numerical fill/colour scales\n\nLet's get back to our initial scatterplot and colour the points by income:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010, \n       mapping = aes(x = children_per_woman, y = life_expectancy)) +\n  geom_point(aes(colour = income_per_person))\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\nBecause `income_per_person` is a continuous variable, *ggplot* created a *gradient* colour scale.\n\nWe can change the default using `scale_colour_gradient()`, defining two colours for the lowest and highest values (and we can also log-transform the data like before):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010, \n       mapping = aes(x = children_per_woman, y = life_expectancy)) +\n  geom_point(aes(colour = income_per_person)) +\n  scale_colour_gradient(low = \"steelblue\", high = \"brown\", trans = \"log10\")\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n\nFor continuous colour scales we can use the [*viridis* palette](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html), which has been developed to be colour-blind friendly and perceptually better:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010, \n       mapping = aes(x = children_per_woman, y = life_expectancy)) +\n  geom_point(aes(colour = income_per_person)) +\n  scale_colour_viridis_c(trans = \"log10\")\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\n### Change a discrete axis scale\n\nEarlier, when we did our boxplot, the x-axis was a categorical variable.\n\nFor categorical axis scales, you can use the `scale_x_discrete()` and `scale_y_discrete()` functions. For example, to *limit* which categories are shown and in which order:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder2010, aes(x = world_region, y = children_per_woman)) +\n  geom_boxplot(aes(fill = is_oecd)) +\n  scale_x_discrete(limits = c(\"europe_central_asia\", \"america\"))\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n\n### Change categorical colour/fill scales\n\nTaking the previous plot, let's change the `fill` scale to define custom colours \"manually\".\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder2010, aes(x = world_region, y = children_per_woman)) +\n  geom_boxplot(aes(fill = is_oecd)) +\n  scale_x_discrete(limits = c(\"europe_central_asia\", \"america\")) +\n  scale_fill_manual(values = c(\"TRUE\" = \"brown\", \n                               \"FALSE\" = \"green3\"))\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n\nFor colour/fill scales there's a very convenient variant of the `scale` function (\"brewer\") that has some pre-defined palettes, including colour-blind friendly ones:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The \"Dark2\" palette is colour-blind friendly\nggplot(gapminder2010, aes(x = world_region, y = children_per_woman)) +\n  geom_boxplot(aes(fill = is_oecd)) +\n  scale_x_discrete(limits = c(\"europe_central_asia\", \"america\")) +\n  scale_fill_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n\nYou can see all the available palettes [here](https://r4ds.had.co.nz/graphics-for-communication.html#fig:brewer). Note that some palettes only have a limited number of colours and `ggplot` will give a warning if it has fewer colours available than categories in the data.\n\n:::: discussion\n## Exercise {.unnumbered}\n\nModify the following code so that the point size is defined by the population size. The size should be on a log scale.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010, \n       mapping = aes(x = children_per_woman, y = life_expectancy)) +\n  geom_point(aes(colour = world_region)) +\n  scale_colour_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n## Solution\n\nTo make points change by size, we add the *size* aesthetic within the `aes()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010, \n       mapping = aes(x = children_per_woman, y = life_expectancy)) +\n  geom_point(aes(colour = world_region, size = population)) +\n  scale_colour_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\n\nIn this case the scale of the point's size is on the original (linear) scale. To transform the scale, we can use `scale_size_continuous()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder2010, \n       mapping = aes(x = children_per_woman, y = life_expectancy)) +\n  geom_point(aes(colour = world_region, size = population)) +\n  scale_colour_brewer(palette = \"Dark2\") +\n  scale_size_continuous(trans = \"log10\")\n```\n\n::: {.cell-output-display}\n![](ESRM6990V_Lecture08_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\n:::\n::::\n\n## Saving graphs\n\nTo save a graph, you can use the `ggsave()` function, which needs two pieces of information:\n\n-   The *filename* where it will save the graph to. The extension of this filename will determine the format of the file (e.g. `.pdf`, `.png`, `.jpeg`).\n-   The *plot* you want to save. This can either be an object with a ggplot or, if not specified, it will be the last plot on your plotting window.\n\nYou can also specify options for the size of the graph and dpi (for PNG or JPEG).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save the plot stored in our \"p\" object as a PDF\n# it will be 15cm x 7cm (default units is inches)\nggsave(filename = \"figures/fertility_vs_life_expectancy.pdf\",\n       plot = p, \n       width = 15, \n       height = 7, \n       units = \"cm\")\n```\n:::\n\n\n\nAnother easy way to save your graphs is by using RStudio's interface. From the \"Plots\" panel there is an option to \"Export\" the graph. However, doing it with code like above ensures reproducibility, and will allow you to track which files where generated from which script.\n\n## Customising your graphs\n\nEvery single element of a ggplot can be modified. This is further covered in a [future episode](%7B%7B%20page.root%20%7D%7D%7B%%20link%20_episodes/10-data_vis_partII.md%20%%7D).\n\n------------------------------------------------------------------------\n\n::: callout-note\n## Data Tip: visualizing data\n\nData visualization is one of the fundamental elements of data analysis. It allows you to assess variation within variables and relationships between variables.\n\nChoosing the right type of graph to answer particular questions (or convey a particular message) can be daunting. The [data-to-viz](https://www.data-to-viz.com/) website can be a great place to get inspiration from.\n\nHere are some common types of graph you may want to do for particular situations: - Look at variation within a single variable using *histograms* (`geom_histogram()`) or, less commonly (but [quite useful](https://towardsdatascience.com/what-why-and-how-to-read-empirical-cdf-123e2b922480)) *empirical cumulative density function* plots (`stat_ecdf`). - Look at variation of a variable across categorical groups using *boxplots* (`geom_boxplot()`), *violin plots* (`geom_violin()`) or frequency polygons (`geom_freqpoly()`). - Look at the relationship between two numeric variables using *scatterplots* (`geom_point()`). - If your x-axis is ordered (e.g. year) use a line plot (`geom_line()`) to convey the change on your y-variable.\n:::\n",
    "supporting": [
      "ESRM6990V_Lecture08_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}