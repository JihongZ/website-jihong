{
  "hash": "fb2e7411fcc40b58cdb737b27ff6ec92",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lecture 03: R Functions\"\nsubtitle: \"R Function\"\nauthor: \"Jihong Zhang*, Ph.D\"\ninstitute: | \n  Educational Statistics and Research Methods (ESRM) Program*\n  \n  University of Arkansas\ndate: \"2025-01-28\"\ndate-modified: \"2024-10-11\"\nsidebar: false\nexecute: \n  echo: true\n  warning: false\n  eval: false\noutput-location: default\ncode-annotations: below\nhighlight-style: \"nord\"\nformat: \n  uark-revealjs:\n    scrollable: true\n    chalkboard: true\n    embed-resources: false\n    code-fold: false\n    number-sections: false\n    footer: \"ESRM 64503 - Lecture 03: Object/Function/Package\"\n    slide-number: c/t\n    tbl-colwidths: auto\n    output-file: slides-index.html\n---\n\n\n\n# R Function\n\n## Prebuilt functions\n\n-   **Functions**: Once we defined the objects, the data analysis process can usually be described as [a series of *functions*]{.underline} applied to the data.\n\n    -   In other words, we considered \"function\" as a set of pre-specified operations (e.g., macro in SAS)\n\n    -   R includes several **predefined functions** and most of the analysis pipelines we construct make extensive use of these.\n\n    -   We already used or discussed the `install.packages`, `library`, and `ls` functions. We also used the function `sqrt` to solve the quadratic equation above.\n\n-   **Evaluation**: In general, we need to use parentheses followed by a function name to evaluate a function.\n\n    -   If you type `ls`, the function is not evaluated and instead R shows you the code that defines the function. If you type [`ls()`](https://rdrr.io/r/base/ls.html) the function is evaluated and, as seen above, we see objects in the workspace.\n\n-   **Function Arguments:** Unlike `ls`, most functions require one or more *arguments* to specify the settings of the function.\n\n    -   For example, we assign different object to the argument of the function `log`. Remember that we earlier defined `coef_a` to be 1:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.079442\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Functions in R\n\n### Overview of Functions\n\n- **Definition**: Functions are blocks of code designed to perform specific tasks.\n- **Purpose**: \n    - Automate repetitive tasks.\n    - Increase code reusability and readability.\n      - A good rule of thumb is to consider writing a function whenever you’ve copied and pasted a block of code more than twice \n- **Key Characteristics**:\n    - Inputs (arguments) → Process → Output (return value).\n    - Functions can contain other functions.\n\n---\n\n### Benefits of Using Functions\n\n1. **Code Reusability**: Write once, use multiple times.\n2. **Readability**: Simplify complex code.\n3. **Debugging**: Isolate errors within specific functions.\n4. **Scalability**: Build modular, extensible codebases.\n\n# Factor Creation\n\n## Helpful function: Pipe\n\n- In R, a pipe is a powerful operator (\"|>\" or \"%>%\") used to streamline the flow of data analysis. \n\n- It enables chaining multiple operations together in a readable, sequential manner. \n\n- Key idea: The pipe operator passes the output of one function as the first argument to the next function, eliminating the need for intermediate variables or nested function calls.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> function1() |> function2() |> function3()\n```\n:::\n\n\n\nThis is equivalent to:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction3(function2(function1(data)))\n```\n:::\n\n\n\n--- \n\n### Example: With vs. Without Pipe\n\nExample: Without Pipe\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Without pipe\nresult <- filter(mtcars, mpg > 20)\nresult <- select(result, mpg, cyl)\nresult <- arrange(result, desc(mpg))\n```\n:::\n\n\n\nExample: With Pipe\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# With pipe\nmtcars |> \n  filter(mpg > 20) |> \n  select(mpg, cyl) |> \n  arrange(desc(mpg))\n```\n:::\n\n\n\n- Which one you prefer?\n\n\n\n## Creating Custom Function\n\n### Example: Celsius to Fahrenheit Converter\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncelsius_to_fahrenheit <- function(temp_c) {\n  temp_f <- (temp_c * 9/5) + 32\n  return(temp_f)\n}\n\ncelsius_to_fahrenheit(25)  # Output: 77\n```\n:::\n\n\n\n- Converts a temperature from Celsius to Fahrenheit.\n- Input: `temp_c` (temperature in Celsius).\n- Output: `temp_f` (temperature in Fahrenheit).\n\n---\n\n### Example: Standardization\n\n- Did you spot the mistake? \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\ndf <- tibble(\n  a = rnorm(5),\n  b = rnorm(5),\n  c = rnorm(5),\n  d = rnorm(5),\n)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n       a      b      c      d\n   <dbl>  <dbl>  <dbl>  <dbl>\n1 -0.800 -0.560 -1.22   1.73 \n2 -1.04   0.397  1.18  -1.04 \n3 -0.520  1.41   0.305  1.44 \n4  1.29   0.206  1.07  -0.751\n5 -0.295 -0.627 -0.779 -0.309\n```\n\n\n:::\n\n```{.r .cell-code}\ndf |> mutate(\n  a = (a - mean(a, na.rm = TRUE)) / sd(a),\n  b = (b - mean(a, na.rm = TRUE)) / sd(b),\n  c = (c - mean(c, na.rm = TRUE)) / sd(c),\n  d = (d - mean(d, na.rm = TRUE)) / sd(d),\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n        a      b      c      d\n    <dbl>  <dbl>  <dbl>  <dbl>\n1 -0.574  -0.674 -1.23   1.18 \n2 -0.836   0.478  0.988 -0.978\n3 -0.269   1.70   0.178  0.955\n4  1.70    0.248  0.891 -0.752\n5 -0.0232 -0.756 -0.826 -0.408\n```\n\n\n:::\n:::\n\n\n\n- `tibble` creates a data frame with 4 columns\n- `mutate` creates new columns - generate standardized scores of all columns\n\n---\n\n- Extract the \"**argument**\":\n  - The **arguments** are things that vary across calls and our analysis above tells us that we have just one. We’ll call it x because this is the conventional name for a numeric vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstandardized <- function(x){\n  (x - mean(x, na.rm = TRUE)) / sd(x)\n}\n\ndf |> mutate(\n  a = standardized(a),\n  b = standardized(b),\n  c = standardized(c),\n  d = standardized(d)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n        a       b      c      d\n    <dbl>   <dbl>  <dbl>  <dbl>\n1 -0.574  -0.873  -1.23   1.18 \n2 -0.836   0.280   0.988 -0.978\n3 -0.269   1.50    0.178  0.955\n4  1.70    0.0490  0.891 -0.752\n5 -0.0232 -0.954  -0.826 -0.408\n```\n\n\n:::\n:::\n\n\n\n---\n\n### Exercise: Rescale\n\n- Create a new function called `rescale` to simplify following code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> mutate(\n  a = (a - mean(a, na.rm = TRUE)) / (max(a) - min(a)),\n  b = (b - mean(b, na.rm = TRUE)) / (max(b) - min(b)),\n  c = (c - mean(c, na.rm = TRUE)) / (max(c) - min(c)),\n  d = (d - mean(d, na.rm = TRUE)) / (max(d) - min(d)),\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n         a       b       c      d\n     <dbl>   <dbl>   <dbl>  <dbl>\n1 -0.226   -0.356  -0.555   0.547\n2 -0.329    0.114   0.445  -0.453\n3 -0.106    0.611   0.0802  0.442\n4  0.671    0.0200  0.402  -0.348\n5 -0.00914 -0.389  -0.372  -0.189\n```\n\n\n:::\n:::\n\n\n\n- The basic skeleton of function is like this: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname <- function(arguments) {\n  body\n}\n```\n:::\n\n\n\n- A name. Here we’ll use 'rescale' because this function rescales a vector to lie between 0 and 1.\n\n- The body. The body is the code that’s repeated across all the calls.\n\n\n## Anatomy of a Function\n\n### Example Code for one function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name <- function(argument1, argument2 = default_value) {\n  # Body of the function\n  result <- argument1 + argument2\n  return(result)\n}\n```\n:::\n\n\n\n- **Components**:\n    - `function_name`: Name of the function.\n    - `arguments`: Inputs provided to the function.\n    - `body`: Code block that performs the computation.\n    - `return()`: Specifies the output of the function.\n\n---\n\n## Arguments in Functions\n\n### Default Arguments\n\n- Assign default values to arguments to make them optional.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreet <- function(name = \"World\") {\n  return(paste(\"Hello,\", name))\n}\n\ngreet()            # Output: \"Hello, World\"\ngreet(\"R User\")    # Output: \"Hello, R User\"\n```\n:::\n\n\n\n### Flexible Arguments\n\n- `...`: Allow a function to accept a variable number of arguments.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_numbers <- function(...) {\n  numbers <- c(...) # combine into a vector\n  return(sum(numbers))\n}\n\nsum_numbers(1, 2, 3, 4)  # Output: 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\n- Look at the help page of `mean`, tell me why we can have `y` argument in `mean` function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x = c(1, 2, 3), y = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n--- \n\n- Flexible argument can be useful when you do not know users want to use which argument\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(y = 3, x = 8, z = 9, one_vector = c(7, TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\n(3 + 8 + 9 + 7 + 1 ) / 5 # what we expect\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.6\n```\n\n\n:::\n\n```{.r .cell-code}\nflexible_mean <- function(...){\n  return(mean(x = c(...)))\n}\nflexible_mean(y = 3, x = 8, z = 9, one_vector = c(7, TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.6\n```\n\n\n:::\n:::\n\n\n\n- Question: test the `sum` function, tell me why `sum` can accept flexible arguments.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(y = 3, x = 8, z = 9, one_vector = c(7, TRUE))\n```\n:::\n\n\n\n\n---\n\n## Returning Values\n\n- Functions return the last evaluated expression by default.\n- Use `return()` for clarity.\n\n### Example: Summing Two Numbers\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd <- function(x, y) {\n  return(x + y)\n}\n\nadd(10, 5)  # Output: 15\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n:::\n\n\n\n---\n\n## Nested Functions\n\n- Functions can call other functions.\n\n### Example: Calculating BMI\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbmi <- function(weight, height) {\n  return(weight / (height^2))\n}\n\nbmi(70, 1.75)  # Output: 22.86\n```\n:::\n\n\n\n- Combines mathematical operations into a single function.\n\n---\n\n## Function Scope\n\n- **Local Scope**: Variables defined inside a function are local to that function.\n- **Global Scope**: Variables defined outside a function are accessible throughout the script.\n\n### Example: Local Scope\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd <- function(x, y) {\n  result <- x + y\n  return(result)\n}\n\nadd(2, 3)   # Output: 5\nresult      # Error: object 'result' not found\n```\n:::\n\n\n\n---\n\n\n\n\n## Summary\n\n- Functions are the cornerstone of programming in R.\n- They encapsulate reusable logic, making code efficient and modular.\n- Key concepts include arguments, return values, and scope.\n- Practice writing functions to automate tasks and solve complex problems.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}